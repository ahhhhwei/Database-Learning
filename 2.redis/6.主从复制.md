# 主从复制

分布式系统，涉及到一个非常关键的问题：单点问题。如果某个服务器程序只有一个节点（只有一个物理服务器）：

- 可用性问题：如果这个机器挂了，意味着服务就中断了。
- 性能 / 支持的并发量也是比较有限的

在分布式系统中，希望使用多个服务器来部署 redis，存在以下几种 redis 部署方式

1. 主从模式

   引入从节点后，把主节点上的数据复制出来放到从节点上。后续主节点对数据有任何修改，都会同步到从节点上。Redis 主从模式中，从节点上的数据不允许修改。

   **主从模式主要针对读操作的高并发和高可用，而写操作非常依赖主节点**

2. 主从 + 哨兵模式

3. 集群模式

## 一、配置

### 1.启动多个 redis-server

首先拷贝两份配置文件作为从节点的：

![](./pic/6-配置文件拷贝.png)

从节点1：

修改端口号为 6380：

![](./pic/6-6380.png)

修改 daemonize 为 yes，按照后台进程的方式来运行：

![](./pic/6-daemonize1.png)

保护模式设置为 no：

![](./pic/6-保护模式1.png)

bind 的 IP 改为 0.0.0.0：

![](./pic/6-bindIP.png)

从节点2：

端口号设置为 6381：

![](./pic/6-6381.png)

其他和从节点 1 一致。

启动两个从节点，发现多了两个进程：

![](./pic/6-启动两个从节点.png)

### 2.配置主从

参与复制的 Redis 实例划分为主节点（master）和从节点（slave）。每个从结点只能有一个主节点， 而一个主节点可以同时具有多个从结点。复制的数据流是单向的，只能由主节点到从节点。 配置复制的方式有以下三种：

1. 在配置文件中加入 `slaveof {masterHost} {masterPort}` 随 Redis 启动生效。**更多使用！**

   ![](./pic/6-slaveof.png)

   **改配置文件后需要重新启动**

   ![](./pic/6-重启.png)

   kill -9 这种停止方式和之前直接运行 redis-server 命令的方式搭配使用

   而如果是 service redis-server start 启动，则必须 service redis-server stop 进行停止（kill -9 杀死进程后会自动启动）

   > 服务器就是要稳定性和高可用，但是服务器上的程序难免会有挂了的时候，这时候需要守护进程监控它的运行状态，对它进行自动重启。

2. 在 redis-server 启动命令时加入 `--slaveof {masterHost} {masterPort}` 生效。

3. 直接使用 redis 命令：`slaveof {masterHost} {masterPort}` 生效。

下图是主从复制效果，主节点的数据可以同步给从节点，而从节点只可读不可写：

![](./pic/6-主从复制效果.png)

查看配置的主从结构的信息：`info replication`

主节点上执行：

![](./pic/6-查看主从结构信息.png)

offset 是一个字节级别的计数器，记录主节点已经传播给从节点的写命令流的位置。

> 主节点上会收到源源不断的修改数据的请求，从节点就需要从主节点把这些修改后的数据做出同步，但是这个同步操作不是瞬间完成的。

lag 是 Redis 主从复制中从节点与主节点通信延迟的时间差，它衡量的是从节点上一次向主节点汇报自己复制进度（ACK）的时间与主节点当前时间的差值。

> 在 Redis 的复制协议中，从节点会定期（默认每秒一次）向主节点发送：
>
> ```shell
> REPLCONF ACK <replication_offset>
> ```
>
> 这条命令告诉主节点：
>
> > “我现在已经复制到了 offset = xxx。”
>
> 主节点收到后，会记录下从节点的最后 ACK 时间。
>  Redis 每秒检查一次，如果距离上次 ACK 超过 `1` 秒，就认为存在延迟，于是：
>
> ```shell
> lag = 当前时间 - 上次ACK时间
> ```
>
> | lag 值 | 含义                                                 |
> | ------ | ---------------------------------------------------- |
> | 0      | 从节点刚刚发过 ACK，主从连接健康、同步实时。         |
> | 1      | 有轻微延迟（通常网络或调度原因），一般无碍。         |
> | ≥2     | 表示从节点同步有明显延迟，可能网络问题或从节点卡顿。 |
>
> 当 `lag` 值持续变大，说明主从之间通信不畅，主节点无法确定从节点的最新进度，会在高可用机制（如 Sentinel）中被认为“不健康”。

```shell
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:237494
```

这些是 redis 主从复制的 **复制积压缓冲区** 的状态，支持 **部分同步** 机制的实现。

从节点上执行：

![](./pic/6-查看主从结构信息（从节点执行）.png)

断开主从连接：`slaveof no one`

![](./pic/断开主从连接.png)

在 `Redis` 中，`SLAVEOF` 命令 **不是永久的**。它的效果是 **即时生效但非持久化**，想让它 “永久生效”，就要写进 `redis.conf`。

断开复制的主要流程：

1. 断开与主节点的复制关系
2. 从节点晋升为主节点

从节点断开复制后不会抛弃原有数据，只是无法再获取主节点上的数据变化

通过 `slaveof` 命令还可以实现切主操作，将当前从节点的数据源切换到另一个主节点。 

执行命令：

```bash
slaveof {newMasterIp} {newMasterPort}
```

**切主操作主要流程：**

1. 断开与旧主节点复制关系。
2. 与新主节点建立复制关系。
3. 删除从节点当前所有数据。
4. 从新主节点进行复制操作。

#### 2.1 安全性

对于数据比较重要的节点，主节点会通过设置 `requirepass` 参数进行密码验证，这时所有的客户端访问必须使用 `auth` 命令实行校验。 从节点与主节点的复制连接是通过一个特殊标识的客户端来完成，因此需要配置从节点的 `masterauth` 参数与主节点密码保持一致，这样从节点才可以正确地连接到主节点并发起复制流程。

#### 2.2 只读

默认情况下，从节点使用 `slave-read-only=yes` 配置为只读模式。  由于复制只能从主节点到从节点，对于从节点的任何修改主节点都是无感知的，修改从节点会造成主从数据不一致。  所以建议线上不要修改从节点的只读模式。

#### 2.3 传输延迟

主从节点一般部署在不同机器上，复制时的网络延迟就成为需要考虑的问题。 Redis 为我们提供了 `repl-disable-tcp-nodelay` 参数用于控制是否关闭 TCP_NODELAY，默认值为 `no`，即开启 `tcp-nodelay` 功能，说明如下：

- **当关闭时**：主节点产生的命令数据无论大小都会及时发送给从节点，这样主从之间延迟会变小，但增加了网络带宽的消耗。适用于主从之间网络环境良好的场景，如同机房部署。

- **当开启时**：主节点会合并较小的 TCP 数据包后再发送。默认发送时间间隔取决于 Linux 的内核，一般认为为 40 毫秒。这种配置节省了带宽但增加了主从之间的延迟。适用于主从网络环境较复杂的场景，如跨机房部署。

> TCP 内部支持了 nagle 算法，开启了就会增加 tcp 的传输延迟，但会节省网络带宽；关闭了就会减少 tcp 的网络延迟，但会增加网络带宽。这个算法默认开启，一般游戏开发需要关闭，尤其是即时性要求很高的（fps、moba）。目的和 tcp 的捎带应答是一样的，针对小的 tcp 数据报，进行合并。

## 二、拓扑

Redis 的复制拓扑结果可以支持单层或多层复制关系，根据拓扑复杂性可以分为以下三种：一主一从、一主多从、树状主从

### 1.一主一从结构

```mermaid
architecture-beta
    service master(database)[Redis Master]
    service slave(database)[Redis Slave]
    service read(internet)[read]
    service write(internet)[write]
    master:R --> L:slave
    read:B --> T:master
    read:B --> T:slave
    write:B --> T:master
```

如果写数据请求太多，此时也会给主节点造成一些压力，可以关闭主节点的 AOF，只在从节点上开启 AOF，这样既可以保证数据的安全性，又能避免持久化对主节点的性能干扰。但是这种设定方式有一个严重的缺陷，主节点一旦挂了，不能让他自动重启（没有 AOF 文件），所以需要主节点从从节点拉取 AOF 文件，再启动。

### 2.一主多从结构

```mermaid
architecture-beta
    service master(database)[Redis Master]
    service slave1(database)[Redis Slave1]
    service slave2(database)[Redis Slave2]
    service slave3(database)[Redis Slave3]
    service slave4(database)[Redis Slave4]
    
    master:L --> R:slave1
    master:T --> B:slave2
    master:R --> L:slave3
    master:B --> T:slave4
```

一主多从结构（星型结构）是的应用端可以利用多个从节点来实现读写分离。但是随着从节点个数的增加，同步一条数据，就需要传输多次。

### 3.树状主从结构

```mermaid
architecture-beta
    service master(database)[master]
    service slave1(database)[slave1]
    service slave2(database)[slave2]
    service slave3(database)[slave3]
    service slave4(database)[slave4]
    junction junctionCenter
    junction junctionRight

    master:B --> T:junctionCenter
    slave1:R <-- L:junctionCenter
    slave2:L >-- R:junctionCenter
    slave1:B --> T:junctionRight
    slave3:R <-- L:junctionRight
    slave4:L >-- R:junctionRight

```

此时主节点不需要那么高的网卡带宽了，但是一旦数据修改了，同步的延时是更长的。

## 三、原理