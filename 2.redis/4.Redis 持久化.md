# Redis 持久化

redis 是一个内存数据库，是把数据存在内存中的，为了持久化，硬盘上也存一份数据（理论上两份数据相同）。Redis 支持 RDB 和 AOF 两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复。

## 一、RDB

RDB 持久化是把当前进程数据生成快照保存到硬盘的过程，触发 RDB 持久化过程分为手动触发和自动触发。

### 1.1 触发机制

- 手动触发：程序员通过 Redis 客户端执行特定的命令，触发快照生成，对应 save 和 bgsave 命令
  - save 命令：阻塞当前 Redis 服务器，直到 RDB  过程完成为止，对于内存比较大的实例造成较长时间的阻塞，基本没用（类似于 `keys *`）
  - bgsave 命令：Redis 进程执行 fork 操作创建子进程，RDB 持久化由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。（Redis 采用多进程的方式来完成并发编程 bgsave 任务）
- 自动触发：在 Redis 配置文件中设置，让 Redis 每隔多长时间 / 每产生多少次修改就触发
  - 使用 save 配置，如 `save m n` 表示 m 秒内数据集发生了 n 次修改，自动 RDB 持久化
  - 从节点进行全量复制操作时，主节点自动进行 RDB 持久化，随后将 RDB 文件内容发送给从节点
  - 执行 shutdown 命令关闭 Redis 时，执行 RDB 持久化

### 1.2 bgsave 持久化流程

bgsave 是主流的 RDB 持久化方式，下图是它的运作流程：

![bgsave](./pic/4-bgsave.png)

1. 执行 bgsave 命令，Redis 父进程判断当前是否存在其他正在执行的子进程，如 RDB/AOF 子进程，如果存在，bgsave 命令直接返回。

   > fork 创建子进程，直接把当前的进程（父）复制一份作为子进程，一旦复制完成了。父子就是两个独立的进程，各自执行各自的代码。这里的复制会复制 PCB，虚拟地址空间（内存中的数据），文件描述符表（父进程打开了一个文件，fork 了之后，子进程也是同样可以使用的）。
   >
   > 这里用到了 **写时拷贝** 的技术，当父子一方有数据修改时，才会真正触发物理上的拷贝。在进行 bgsave 的这个场景中，绝大部分的内存数据是不需要修改的（整体来说这个过程还执行得挺快的，这个短时间内，父进程不会有大批的内存数据变化）。因此写时拷贝不会触发很多次，整体的拷贝时间是可控的。
   >
   > 本来 redis server 中有若干变量，保存了一些键值对数据，随着这样的 fork 的进行，子进程的这个内存里也会存在和刚才父进程中一模一样的变量。因此，复制出来的子进程的内存中的数据和父进程的数据是一样的。接下来安排子进程进行持久化操作，也就相当于把父进程本体这里的内存数据给持久化了。

2. 父进程执行 fork 创建子进程，fork 过程中父进程会阻塞，通过 info stats 命令查看 latest_fork_usec 选项，可以获取最近一次 fork 操作的耗时，单位为微秒。

3. 父进程 fork 完成后，bgsave 命令返回 "Background saving started" 信息并不再阻塞父进程，可以继续响应其他命令。

4. 子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行 lastsave 命令可以获取最后一次生成 RDB 的时间，对应 info 统计的 rdb_last_save_time 选项。

   > 执行生成 RDB 镜像操作的时候，会把要生成的快照数据先保存的一个临时文件中，当这个快照生成完毕之后，再删除之前的 RDB 文件，把临时文件改名为 dump.rdb

5. 进程发送信号给父进程表示完成，父进程更新统计信息。

### 1.3 RDB 文件的处理

![](./pic/4-save.png)

`save 3600 1` 的意思是 1h 且至少有 1 次修改，才会触发 rdb，虽然此处的这些数值都可以自由修改配置，但是修改时还是要遵守一个原则：生成一侧 rdb 快照的成本很高，不能让这个操作太频繁。正因为 rdb 生成的不能太频繁，这就导致快照里的数据和当前实时的数据情况可能有偏差。

> 如果设置为 save "" 则是关闭自动生成快照功能

**手动 save**

![](./pic/4-rdb1.png)

![](./pic/4-rdb2.png)

redis 生成快照操作，不仅仅时手动执行命令才会触发，也可以自动触发：

- 刚才的配置文件中，save 执行 M 时间内，修改 N 次
- 通过 shutdown 命令（redis 里的一个命令）关闭 redis 服务器，也会触发（service redis-server restart）
- redis 进行主从复制的时候，主节点也会自动生成 rdb 快照，然后把 rdb 快照文件内容传输给从节点

> 执行 flushall 的时候也会清空 rdb 文件

![](./pic/4-redis异常关闭.png)

如果异常重启（kill -9/断电），此时 redis 服务器来不及生成 rdb。

**保存：**RDB 文件保存再 dir 配置指定的目录（默认 /var/lib/redis/ 下），文件名通过 dbfilename 配置（默认 dump.rdb）指定。可以通过执行 config set dir {newDir} 和 config set dbfilename {newFilename} 运行期间动态执行，当下次运行时 RDB 文件会保存到新目录。

![](./pic/4-inode.png)

在使用 bgsave 前后，分别查看 dump.rdb 的 inode 编号，发现改变了

> Linux 文件系统
>
> 文件系统典型的组织方式（ext4）主要是把整个文件系统分成了三个大部分
>
> 1. 超级块（放的是一些管理信息）
> 2. inode 区（存放 inode 节点，每个文件都会分配一个 inode 数据结构，包含了文件的各种元数据）
> 3. block 区，存放文件的数据内容

如果使用 save 命令，是不会触发子进程&文件替换的逻辑的，它会直接在当前进程中，往刚才的同一个文件中写数据。

**压缩：**Redis 默认采用 LZF 算法对生成的 RDB 文件做压缩处理，压缩后的文件远远小于内存大小，默认开启，可以通过参数 config set rdbcompression {yes|no} 动态修改。

> 如果把 rdb 文件改坏了，会怎么样？
>
> 文件末尾可能没啥影响，如果是 rdb 文件中间坏了可能就出问题了（启动不了）
>
> rdb 文件检查工具
>
> ![](./pic/4-check-rdb.png)
>
> 检查工具和服务器是同一个可执行程序，可以在运行的时候加入不同的选项从而实现不同的功能
>
> ![](./pic/4-check-rdb检查.png)

### 1.4 RDB 的优缺点

1. RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据快照。 非常适用于备份、全量操作等场景，比如每 6 小时执行 bgsave 备份，并把 rdb 文件复制到远程机器或者文件系统中（如 hdfs）用于灾备

2. Redis 加载 RDB 恢复数据远远快于 AOF 的方式

   > RDB 使用二进制的方式来组织数据，直接把数据读取到内存，按照字节的格式读取出来放到结构体 / 对象中
   >
   > AOF 是使用文本的方式来组织数据的，则需要纪念性一系列字符切分操作

3. RDB 方式数据没办法做到 **实时持久化 / 秒级持久化**。因为 bgsave 每次运行都要 fork 创建子进程，属于重量级操作频繁执行成本过高

4. RDB 文件使用特定二进制格式保存，Redis 版本演进过程中有多个 RDB 版本，兼容性可能有风险
