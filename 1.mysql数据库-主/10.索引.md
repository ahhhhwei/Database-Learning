# 10.索引

## 一、没有索引，可能会有什么问题

索引：提高数据库的性能，索引是物美价廉的东西了。不用加内存，不用改程序，不用调`sql`，只要执行正确的`create index`，查询速度就可能提高成百上千倍。但是天下没有免费的午餐，查询速度的提高是以插入、更新、删除的速度为代价的，这些写操作，增加了大量的`IO`。所以它的价值，在于提高一个海量数据的检索速度。

**常见索引分为：**

- 主键索引(`primary key`)
- 唯一索引(`unique`)
- 普通索引(`index`)
- 全文索引(`fulltext`)：解决中子文索引问题。

![image-20230512194747474](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230512194747474.png)

![image-20230512200045238](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230512200045238.png)

先建一个海量表，在没有索引时会出现什么问题？

```sql
--构建一个8000000条记录的数据
--构建的海量表数据需要有差异性，所以使用存储过程来创建， 拷贝下面代码就可以了，暂时不用理解
-- 产生随机字符串
delimiter $$
create function rand_string(n INT)
returns varchar(255)
begin
declare chars_str varchar(100) default
'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
declare return_str varchar(255) default '';
declare i int default 0;
while i < n do
set return_str =concat(return_str,substring(chars_str,floor(1+rand()*52),1));
set i = i + 1;
end while;
return return_str;
end $$
delimiter ;
--产生随机数字
delimiter $$
create function rand_num()
returns int(5)
begin
declare i int default 0;
set i = floor(10+rand()*500);
return i;
end $$
delimiter ;
--创建存储过程，向雇员表添加海量数据
delimiter $$
create procedure insert_emp(in start int(10),in max_num int(10))
begin
declare i int default 0;
set autocommit = 0;
repeat
set i = i + 1;
insert into EMP values ((start+i)
,rand_string(6),'SALESMAN',0001,curdate(),2000,400,rand_num());
until i = max_num
end repeat;
commit;
end $$
delimiter ;
-- 执行存储过程，添加8000000条记录
call insert_emp(100001, 8000000);
```

到此，已经创建出了海量数据的表了。

- 查询员工编号为998877的员工

  ```sql
  mysql> select * from EMP where empno=998877;
  +--------+--------+----------+------+---------------------+---------+--------+--------+
  | empno  | ename  | job      | mgr  | hiredate            | sal     | comm   | deptno |
  +--------+--------+----------+------+---------------------+---------+--------+--------+
  | 998877 | AUXdxe | SALESMAN | 0001 | 2023-05-12 00:00:00 | 2000.00 | 400.00 |     64 |
  +--------+--------+----------+------+---------------------+---------+--------+--------+
  1 row in set (11.61 sec)
  ```

  可以看到耗时11.61秒，这还是在本机一个人来操作，在实际项目中，如果放在公网中，假如同时有1000个人并发查询，那很可能就死机。

- 解决方法，创建索引

  ```sql
  mysql> alter table EMP add index(empno);
  Query OK, 0 rows affected (45.89 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  ```

- 换一个员工编号，测试看看查询时间

  ```sql
  mysql> select * from EMP where empno=123456;
  +--------+--------+----------+------+---------------------+---------+--------+--------+
  | empno  | ename  | job      | mgr  | hiredate            | sal     | comm   | deptno |
  +--------+--------+----------+------+---------------------+---------+--------+--------+
  | 123456 | WNXAKZ | SALESMAN | 0001 | 2023-05-12 00:00:00 | 2000.00 | 400.00 |    415 |
  +--------+--------+----------+------+---------------------+---------+--------+--------+
  1 row in set (0.00 sec)
  ```

## 二、认识磁盘

- `MySQL`与存储

  `MySQL` 给用户提供存储服务，而存储的都是数据，数据在磁盘这个外设当中。磁盘是计算机中的一个机械设备，相比于计算机其他电子元件，磁盘效率是比较低的，在加上`IO`本身的特征，可以知道，如何提高效率，是 `MySQL` 的一个重要话题。

- 先来研究一下磁盘：

  ![image-20230512195042918](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230512195042918.png)

  ![image-20230512195100672](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230512195100672.png)

1. `mysqld`本质就是一个进程
2. 一定是在操作系统之上运行的
3. 对`mysql`内部的数据等做操作(CURD)的时候，本质就是操作磁盘文件内容
4. 文件必须先被打开，对文件内容做任何操作，都不是直接在磁盘设备上做操作的（对文件内容做操作要通过指令，CPU，内存$$\rightarrow$$任何磁盘数据，在磁盘中要进行操作，本质必须在内存中进行$$\rightarrow$$1.如果不在内存中呢？——换入换出[`mysql`一定有自己的内存管理；2.`mysql`一定要在自己启动的时候申请一批内存空间]）

![image-20230527092455347](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527092455347.png)

`mysql`在启动的时候，预先会在自己的代码中申请一块空间——`byffer pool`



## 三、`Mysql`与磁盘交互基本单位

而`MySQL`作为一款应用软件，可以想象成一种特殊的文件系统。它有着更高的`IO`场景，所以，为了提高基本的`IO`效率， `MySQL`进行`IO`的基本单位是`16KB`(后面统一使用`InnoDB`存储引擎讨论)

```mysql
mysql>  SHOW GLOBAL STATUS LIKE 'innodb_page_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| Innodb_page_size | 16384 |    -- 16*1024=16384
+------------------+-------+
1 row in set (0.05 sec)
```

![image-20230527093934841](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527093934841.png)

也就是说，磁盘这个硬件设备的基本单位是`512`字节（磁盘扇区的大小），而`MySQL InnoDB`引擎 使用`16KB`进行`IO`交互。即`MySQL`和磁盘进行数据交互的基本单位是`16KB`。这个基本数据单元，在`MySQL`这里叫做`page`（注意和系统的`page`区分）

如何能很高效地把成千上万的`page`组织起来？链表？采用更高效的数据结构。

这里说的采用什么样的数据结构来完成对`page`的组织——就是索引的基础

## 四、建立共识

- `MySQL`中的数据文件，是以`page`为单位保存在磁盘当中的。
- `MySQL`的`CURD`操作，都需要通过计算，找到对应的插入位置，或者找到对应要修改或者查询的数据。
- 而只要涉及计算，就需要`CPU`参与，而为了便于`CPU`参与，一定要能够先将数据移动到内存当中。
- 所以在特定时间内，数据一定是磁盘中有，内存中也有。后续操作完内存数据之后，以特定的刷新策略，刷新到磁盘。而这时，就涉及到磁盘和内存的数据交互，也就是`IO`了。而此时`IO`的基本单位就是`Page`。
- 为了更好的进行上面的操作，`MySQL`服务器在内存中运行的时候，在服务器内部，就申请了被称为`Buffer Pool`的的大内存空间，来进行各种缓存。其实就是很大的内存空间，来和磁盘数据进行`IO`交互。
- 为何更高的效率，一定要尽可能的减少系统和磁盘`IO`的次数。

## 五、索引的理解

- 建立测试表

  ```mysql
  create table if not exists `user`(
  	id int primary key,
  	age int not null,
  	name varchar(16) not null
  )
  ```

- 查看表结构

  ```sql
  mysql> desc user;
  +-------+-------------+------+-----+---------+-------+
  | Field | Type        | Null | Key | Default | Extra |
  +-------+-------------+------+-----+---------+-------+
  | id    | int         | NO   | PRI | NULL    |       |
  | age   | int         | NO   |     | NULL    |       |
  | name  | varchar(16) | NO   |     | NULL    |       |
  +-------+-------------+------+-----+---------+-------+
  3 rows in set (0.04 sec)
  ```

- 插入多条记录

  ```sql
  insert into user (id, age, name) values(3, 18, '杨过');
  insert into user (id, age, name) values(4, 16, '小龙女');
  insert into user (id, age, name) values(2, 26, '黄蓉');
  insert into user (id, age, name) values(5, 36, '郭靖');
  insert into user (id, age, name) values(1, 56, '欧阳锋');
  ```

  乱序插入：

  ![image-20230527095434920](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527095434920.png)

但插入后得到的表结构，由乱序变成了有序：

![image-20230527095545631](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527095545631.png)

- 中断一下——为何IO交互要是`Page`

  > 为何`MySQL`和磁盘进行`IO`交互的时候，要采用`Page`的方案进行交互呢?用多少，加载多少不香吗?
  > 如上面的5条记录，如果`MySQL`要查找`id=2`的记录，第一次加载`id=1`，第二次加载`id=2`，一次一条记录，那么就需要2`IO`。如果要找`id=5`，那么就需要5次`IO`。
  > 但，如果这5条(或者更多)都被保存在一个`Page`中(`16KB`，能保存很多记录),那么第一次IO查找`id=2`的时候，整个`Page`会被加载到`MySQL`的`Buffer Pool`中，这里完成了一次`IO`。但是往后如果在查找`id=1,3,4,5`等，完全不需要进行`IO`了，而是直接在内存中进行了。所以，就在单`Page`里面，大大减少了`IO`的次数。
  > 你怎么保证，用户一定下次找的数据，就在这个`Page`里面？我们不能严格保证，但是有很大概率，因为**局部性原理**。
  > 往往`IO`效率低下的最主要矛盾不是`IO`单次数据量的大小，而是`IO`的次数。

- 理解单个`Page`

  `MySQL`中要管理很多数据表文件，而要管理好这些文件，就需要 先描述，在组织 ,我们目前可以简单理解成一个个独立文件是有一个或者多个`Page`构成的。

  ![image-20230527104908501](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527104908501.png)

  不同的`Page`，在`MySQL`中，都是`16KB`，使用`prev`和`next`构成双向链表。

  **因为有主键的问题**，`MySQL`会默认按照主键给我们的数据进行排序，从上面的`Page`内数据记录可以看出，数据是有序且彼此关联的。

  > 为什么数据库在插入数据时要对其进行排序呢？我们按正常顺序插入数据不是也挺好的吗？
  > 插入数据时排序的目的，就是优化查询的效率。
  > 页内部存放数据的模块，实质上也是一个链表的结构，链表的特点也就是增删快，查询修改慢，所以优化查询的效率是必须的。正式因为有序，在查找的时候，从头到后都是有效查找，没有任何一个查找是浪费的，而且，如果运气好，是可以提前结束查找过程的。

- 理解多个`Page`

  通过上面的分析，我们知道，上面页模式中，只有一个功能，就是在查询某条数据的时候直接将一整页的数据加载到内存中，以减少硬盘IO次数，从而提高性能。但是，我们也可以看到，现在的页模式内部，实际上是采用了链表的结构，前一条数据指向后一条数据，本质上还是通过数据的逐条比较来取出特定的数据。
  如果有1千万条数据，一定需要多个Page来保存1千万条数据，多个Page彼此使用双链表链接起来，而且每个Page内部的数据也是基于链表的。那么，查找特定一条记录，也一定是线性查找。这效率也太低了。

  ![image-20230527104012372](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527104012372.png)

- 页目录
  - 我们在看《谭浩强C程序设计》这本书的时候，如果我们要看<指针章节>，找到该章节有两种做法
  - 从头逐页的向后翻，直到找到目标内容
  - 通过书提供的目录，发现指针章节在234页(假设)，那么我们便直接翻到234页。同时，查找目录的方案，可以顺序找，不过因为目录肯定少，所以可以快速提高定位
  - 本质上，书中的目录，是多花了纸张的，但是却提高了效率
  - 所以，目录，是一种“空间换时间的做法”

- 单页情况

  针对上面的单页`Page`，我们能否也引入目录呢？当然可以

  ![image-20230527104757528](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527104757528.png)

  那么当前，在一个`Page`内部，我们引入了目录。比如，我们要查找id=4记录，之前必须线性遍历4次，才能拿到结果。现在直接通过目录`2[3]`，直接进行定位新的起始位置，提高了效率。现在我们可以再次正式回答上面的问题了，为何通过键值`MySQL`会自动排序？
  可以很方便引入目录。
  
- 多页情况

  `MySQL`中每一页的大小只有`16KB`，单个`Page`大小固定，所以随着数据量不断增大，`16KB`不可能存下所有的数据，那么必定会有多个页来存储数据。

  ![image-20230527135015017](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527135015017.png)

  在单表数据不断被插入的情况下，`MySQL`会在容量不足的时候，自动开辟新的`Page`来保存新的数据，然后通过指针的方式，将所有的`Page`组织起来。 需要注意，上面的图，是理想结构，大家也知道，目前要保证整体有序，那么新插入的数据，不一定会在新`Page`上面，这里仅仅做演示。
  这样，我们就可以通过多个`Page`遍历，`Page`内部通过目录来快速定位数据。可是，貌似这样也有效率问题，在`Page`之间，也是需要`MySQL`遍历的，遍历意味着依旧需要进行大量的`IO`，将下一个`Page`加载到内存，进行线性检测。这样就显得我们之前的`Page`内部的目录，有点杯水车薪了。
  那么如何解决呢？解决方案，其实就是我们之前的思路，给`Page`也带上目录。使用一个目录项来指向某一页，而这个目录项存放的就是将要指向的页中存放的最小数据的键值。和页内目录不同的地方在于，这种目录管理的级别是页，而页内目录管理的级别是行。
  其中，每个目录项的构成是：键值+指针。图中没有画全。

  ![image-20230527135521535](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527135521535.png)

  存在一个目录页来管理页目录，目录页中的数据存放的就是指向的那一页中最小的数据。有数据，就可通过比较，找到该访问那个`Page`，进而通过指针，找到下一个`Page`。
  其实目录页的本质也是页，普通页中存的数据是用户数据，而目录页中存的数据是普通页的地址。可是，我们每次检索数据的时候，该从哪里开始呢？虽然顶层的目录页少了，但是还要遍历啊？不用担心，可以在加目录页

  ![image-20230527135818952](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527135818952.png)

  这就是传说中的`B+`树啊！没错，至此，我们已经给我们的表`user`构建完了主键索引。
  随便找一个`id=？`我们发现，现在查找的`Page`数一定减少了，也就意味着`IO`次数减少了，那么效率也就提高了。

- 复盘一下
  - `Page`分为目录页和数据页。目录页只放各个下级`Page`的最小键值。
  - 查找的时候，自定向下找，只需要加载部分目录页到内存，即可完成算法的整个查找过程，大大减少了`IO`次数。

- `InnoDB`在建立索引结构来管理数据的时候，其他数据结构为何不行？

  - 链表？线性遍历

  - 二叉搜索树？退化问题，可能退化成为线性结构

  - `AVL`&&红黑树？虽然是平衡或者近似平衡，但是毕竟是二叉结构，相比较多阶`B+`，意味着树整体过高，大家都是自顶向下找，层高越低，意味着系统与硬盘更少的`IO` `Page`交互。虽然你很秀，但是有更秀的。
    `Hash`？官方的索引实现方式中，`MySQL`是支持`HASH`的，不过`InnoDB`和`MyISAM`并不支持。`Hash`跟进其算法特征，决定了虽然有时候也很快(O(1))，不过，在面对范围查找就明显不行，另外还有其他差别，有兴趣可以查一下。

    ![image-20230527144046262](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527144046262.png)

  - B树？最值得比较的是`InnoDB`为何不用B树作为底层索引？

    B树

    ![image-20230527144141132](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527144141132.png)

    B+树

    ![image-20230527144151830](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527144151830.png)

  - 目前这两棵树，对我们最有意义的区别是：
    B树节点，既有数据，又有Page指针，而B+，只有叶子节点有数据，其他目录页，只有键值和Page指针B+叶子节点，全部相连，而B没有。

  - 为何选择B+
    节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，所以IO操作次数更少。叶子节点相连，更便于进行范围查找。

- 主键索引
  1. 具有主键的表，一个表有一棵`B+`树。
  2. 没有主键的表，目前我们认为是所有的数据都是线性的（但是，如果表中没有主键，`mysql`会自动形成隐藏主键）。
  3. `B+`树中所有的叶子节点、路上节点，全部要加载到内存中嘛？——不需要，按需`load MySQL`所需要的`page`。
  4. ![image-20230527143550508](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527143550508.png)

- 聚簇索引 VS 非聚簇索引（数据在不在叶子当中）

  - 聚簇索引（`InnoDB`）

    表中的所有带有主键的数据都是以B+的形式呈现的，其中，`B+`树和数据是耦合在一起的。

  - 非聚簇索引

    `MyISAM`存储引擎-主键索引。
    `MyISAM`引擎同样使用B+树作为索引结果，叶节点的data域存放的是数据记录的地址。下图为`MyISAM`表的主索引，`Col1`为主键。

    ![image-20230527145246258](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230527145246258.png)

    其中，`MyISAM`最大的特点是，将索引`Page`和数据`Page`分离，也就是叶子节点没有数据，只有对应数据的地址。
    相较于`InnoDB`索引，`InnoDB`是将索引和数据放在一起的。
    
    ```mysql
    -- 终端A
    mysql> create database myisam_test; -- 创建数据库
    Query OK, 1 row affected (0.00 sec)
    mysql> use myisam_test;
    Database changed
    mysql> create table mtest(
    -> id int primary key,
    -> name varchar(11) not null
    -> )engine=MyISAM; -- 使用engine=MyISAM
    Query OK, 0 rows affected (0.01 sec)
    -- 终端B
    [root@VM-0-3-centos mysql]# ls myisam_test/ -al --mysql数据目录下
    total 28
    drwxr-x--- 2 mysql mysql 4096 Jun 13 13:33 .
    drwxr-x--x 13 mysql mysql 4096 Jun 13 13:32 ..
    -rw-r----- 1 mysql mysql 61 Jun 13 13:32 db.opt
    -rw-r----- 1 mysql mysql 8586 Jun 13 13:33 mtest.frm -- 表结构数据
    -rw-r----- 1 mysql mysql 0 Jun 13 13:33 mtest.MYD -- 该表对应的数据，当前没有数据，所以是0
    -rw-r----- 1 mysql mysql 1024 Jun 13 13:33 mtest.MYI -- 该表对应的主键索引数据
    
    ```
    
    其中，`MyISAM`这种用户数据与索引数据分离的索引方案，叫做非聚簇索引。
    
    ```mysql
    -- 终端A
    mysql> create database innodb_test; -- 创建数据库
    Query OK, 1 row affected (0.00 sec)
    mysql> use innodb_test;
    Database changed
    mysql> create table itest(
    -> id int primary key,
    -> name varchar(11) not null
    -> )engine=InnoDB; --使用engine=InnoDB
    Query OK, 0 rows affected (0.02 sec)
    -- 终端B
    [root@VM-0-3-centos mysql]# ls innodb_test/ -al
    total 120
    drwxr-x--- 2 mysql mysql 4096 Jun 13 13:39 .
    drwxr-x--x 14 mysql mysql 4096 Jun 13 13:38 ..
    -rw-r----- 1 mysql mysql 61 Jun 13 13:38 db.opt
    -rw-r----- 1 mysql mysql 8586 Jun 13 13:39 itest.frm -- 表结构数据
    -rw-r----- 1 mysql mysql 98304 Jun 13 13:39 itest.ibd -- 该表对应的主键索引和用户数据，虽然现在一行数据没有，但是该表并不为0，因为有主键索引数据
    ```
    
    其中，`InnoDB`这种用户数据与索引数据在一起索引方案，叫做聚簇索引。
    当然，`MySQL`除了默认会建立主键索引外，我们用户也有可能建立按照其他列信息建立的索引，一般这种索引可以叫做辅助（普通）索引。
    对于`MyISAM`,建立辅助（普通）索引和主键索引没有差别，无非就是主键不能重复，而非主键可重复。
    下图就是基于`MyISAM`的`Col2`建立的索引，和主键索引没有差别。
    
    ![image-20230529192935089](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230529192935089.png)
    
    同样，`InnoDB`除了主键索引，用户也会建立辅助（普通）索引，我们以上表中的`Col3`建立对应的辅助索引如下图：
    
    ![image-20230529193043472](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230529193043472.png)
    
    可以看到，`InnoDB`的非主键索引中叶子节点并没有数据，而只有对应记录的`key`值。
    所以通过辅助（普通）索引，找到目标记录，需要两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。这种过程，就叫做回表查询。
    为何`InnoDB`针对这种辅助（普通）索引的场景，不给叶子节点也附上数据呢？原因就是太浪费空间了。
    总结：
    
    - 如何理解硬盘
    - 如何理解柱面，磁道，扇区，磁头
    - `InnoDB`主键索引和普通索引
    - `MyISAM`主键索引和普通索引
    - 其他数据结构为何不能作为索引结构，尤其是`B+`和`B`
    - 聚簇索引`VS`非聚簇索引
    
  - 一张表，不仅仅只有一个索引结构（表的任意一列都可以构建索引），当我们建立表结构的时候，如果有主键，默认`mysqld`会为我们构建主键索引！（聚簇/非聚簇）。
  
    `myisam`存储引擎，构建主键或者普通索引就是构建`B+`，叶子保存数据记录的地址即可。
  
    `innodb`存储引擎，构建主键索引，聚簇的，但是普通索引，只能需要根据普通列表构建`B+`然后叶子上放的就是普通数据对应记录的主键`ID`，后续通过回表的方式进行查找。

## 六、索引操作

**创建主键索引**

- 第一种方式

  ```mysql
  -- 在创建表的时候，直接在字段名后指定 primary key
  create table user1(
      id int primary key, 
      name varchar(30)
  );
  ```

- 第二种方式

  ```mysql
  -- 在创建表的最后，指定某列或某几列为主键索引
  create table user2(
      id int, 
      name varchar(30), 
      primary key(id)
  );
  ```

- 第三种方式

  ```mysql
  create table user3(
      id int, 
      name varchar(30)
  );
  -- 创建表以后再添加主键
  alter table user3 add primary key(id);
  ```

- 主键索引的特点：

  - 一个表中，最多有一个主键索引，当然可以使符合主键
  - 主键索引的效率高（主键不可重复）
  - 创建主键索引的列，它的值不能为`null`，且不能重复
  - 主键索引的列基本上是`int`

**唯一索引的创建**

- 第一种方式

  ```mysql
  -- 在表定义时，在某列后直接指定unique唯一属性。
  create table user4(
      id int primary key, 
      name varchar(30) unique
  );
  ```

- 第二种方式

  ```mysql
  -- 创建表时，在表的后面指定某列或某几列为unique
  create table user5(
      id int primary key, 
      name varchar(30), 
      unique(name)
  );
  ```

- 第三种方式

  ```mysql
  create table user6(
      id int primary key, 
      name varchar(30)
  );
  alter table user6 add unique(name);
  ```

- 唯一索引的特点：

  - 一个表中，可以有多个唯一索引
  - 查询效率高
  - 如果在某一列建立唯一索引，必须保证这列不能有重复数据
  - 如果一个唯一索引上指定`not null`，等价于主键索引

**普通索引的创建**

- 第一种方式

  ```mysql
  create table user8(
      id int primary key,
  	name varchar(20),
  	email varchar(30),
  	index(name) -- 在表的定义最后，指定某列为索引
  );
  ```

- 第二种方式

  ```mysql
  create table user9(
      id int primary key, 
      name varchar(20), 
      email varchar(30)
  );
  alter table user9 add index(name); -- 创建完表以后指定某列为普通索引
  ```

- 第三种方式

  ```mysql
  create table user10(
      id int primary key, 
      name varchar(20), 
      email varchar(30)
  );
  -- 创建一个索引名为 idx_name 的索引
  create index idx_name on user10(name);
  ```

- 普通索引的特点：

  - 一个表中可以有多个普通索引，普通索引在实际开发中用的比较多
  - 如果某列需要创建索引，但是该列有重复的值，那么我们就应该使用普通索引

**全文索引的创建**

当对文章字段或有大量文字的字段进行检索时，会使用到全文索引。`MySQL`提供全文索引机制，但是有要求，要求表的存储引擎必须是`MyISAM`，而且默认的全文索引支持英文，不支持中文。如果对中文进行全文检索，可以使用`sphinx`的中文版(`coreseek`)。

```mysql
CREATE TABLE articles (
	id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
	title VARCHAR(200),
	body TEXT,
	FULLTEXT (title,body)
)engine=MyISAM;
```

```mysql
INSERT INTO articles (title,body) VALUES
	('MySQL Tutorial','DBMS stands for DataBase ...'),
	('How To Use MySQL Well','After you went through a ...'),
	('Optimizing MySQL','In this tutorial we will show ...'),
	('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
	('MySQL vs. YourSQL','In the following database comparison ...'),
	('MySQL Security','When configured properly, MySQL ...');
```

- 查询有没有`database`数据
  如果使用如下查询方式，虽然查询出数据，但是没有使用到全文索引

  ```mysql
  mysql> select * from articles where body like '%database%';
  +----+-------------------+------------------------------------------+
  | id | title | body |
  +----+-------------------+------------------------------------------+
  | 1 | MySQL Tutorial | DBMS stands for DataBase ... |
  | 5 | MySQL vs. YourSQL | In the following database comparison ... |
  +----+-------------------+------------------------------------------+
  ```

  可以用`explain`工具看一下，是否使用到索引

  ```mysql
  mysql> explain select * from articles where body like '%database%'\G
  *************************** 1. row ***************************
  id: 1
  select_type: SIMPLE
  table: articles
  type: ALL
  possible_keys: NULL
  key: NULL <== key为null表示没有用到索引
  key_len: NULL
  ref: NULL
  rows: 6
  Extra: Using where
  1 row in set (0.00 sec)
  ```

- 如何使用全文索引呢？

  ```mysql
  mysql> SELECT * FROM articles
  -> WHERE MATCH (title,body) AGAINST ('database');
  +----+-------------------+------------------------------------------+
  | id | title | body |
  +----+-------------------+------------------------------------------+
  | 5 | MySQL vs. YourSQL | In the following database comparison ... |
  | 1 | MySQL Tutorial | DBMS stands for DataBase ... |
  +----+-------------------+------------------------------------------+
  ```

- 通过`explain`来分析这个`sql`语句

  ```mysql
  mysql> explain SELECT * FROM articles WHERE MATCH (title,body) AGAINST
  ('database')\G
  *************************** 1. row ***************************
  id: 1
  select_type: SIMPLE
  table: articles
  type: fulltext
  possible_keys: title
  key: title <= key用到了title
  key_len: 0
  ref:
  rows: 1
  Extra: Using where
  ```

**查询索引**

- 第一种方法： show keys from 表名

  ```mysql
  mysql> show keys from goods\G
  *********** 1. row ***********
  Table: goods -- <= 表名
  Non_unique: 0 -- <= 0表示唯一索引
  Key_name: PRIMARY -- <= 主键索引
  Seq_in_index: 1
  Column_name: goods_id -- <= 索引在哪列
  Collation: A
  Cardinality: 0
  Sub_part: NULL
  Packed: NULL
  Null:
  Index_type: BTREE -- <= 以二叉树形式的索引
  Comment:
  1 row in set (0.00 sec)
  ```

- 第二种方法: `show index from`表名;

- 第三种方法（信息比较简略）： `desc`表名；

**删除索引**

- 第一种方法-删除主键索引： `alter table 表名 drop primary key;`
- 第二种方法-其他索引的删除： `alter table 表名 drop index 索引名；`索引名就是`show keys from`表名中的`Key_name`字段
  `mysql> alter table user10 drop index idx_name;`
- 第三种方法方法： `drop index 索引名 on 表名`
  `mysql> drop index name on user8`

**索引创建原则**

- 比较频繁作为查询条件的字段应该创建索引
- 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
- 更新非常频繁的字段不适合作创建索引
- 不会出现在`where`子句中的字段不该创建索引