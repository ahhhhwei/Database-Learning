# 06.表的增删查改

——DML

CRUD : Create(创建), Retrieve(读取)，Update(更新)，Delete（删除）

这里`create`只是个单词，不是创建表的那个`create`，未来对应的是`insert`。

## 一、Create

- 语法：

  **`values`左边若不写，则默认为全列插入，包括自增长。**

  ```sql
  INSERT [INTO] table_name
  	[(column [, column] ...)]
  	VALUES (value_list) [, (value_list)] ...
  value_list: value, [, value] ...
  ```

- 案例：

  建表

  ```sql
  mysql> create table students(
      -> id int unsigned primary key auto_increment,
      -> sn int unsigned unique key not null comment '学号',
      -> name varchar(64) unique key,
      -> qq varchar(64) unique key
      -> );
  Query OK, 0 rows affected (0.13 sec)
  
  mysql> desc students;
  +-------+--------------+------+-----+---------+----------------+
  | Field | Type         | Null | Key | Default | Extra          |
  +-------+--------------+------+-----+---------+----------------+
  | id    | int unsigned | NO   | PRI | NULL    | auto_increment |
  | sn    | int unsigned | NO   | UNI | NULL    |                |
  | name  | varchar(64)  | YES  | UNI | NULL    |                |
  | qq    | varchar(64)  | YES  | UNI | NULL    |                |
  +-------+--------------+------+-----+---------+----------------+
  4 rows in set (0.00 sec)
  ```

  插入

  ```sql
  mysql> insert into students (sn, name, qq) values (666, '毛哥', '666@qq.com');
  Query OK, 1 row affected (0.04 sec)
  
  mysql> insert into students (sn, name) values (216, '阿伟');
  Query OK, 1 row affected (0.02 sec)
  
  mysql> select * from students;
  +----+-----+--------+------------+
  | id | sn  | name   | qq         |
  +----+-----+--------+------------+
  |  1 | 666 | 毛哥   | 666@qq.com |
  |  2 | 216 | 阿伟   | NULL       |
  +----+-----+--------+------------+
  2 rows in set (0.00 sec)
  ```

  一次插入多个信息，多个信息之间用`,`隔开：

  ```sql
  mysql> insert into students (sn, name, qq) values (1000, '王子', '1000@qq.com'), (1001, '王紫', '1001@qq.com'), (1002, '王梓', '1002@qq.com');
  Query OK, 3 rows affected (0.01 sec)
  Records: 3  Duplicates: 0  Warnings: 0
  
  mysql> select * from students;
  +----+------+--------+-------------+
  | id | sn   | name   | qq          |
  +----+------+--------+-------------+
  |  1 |  666 | 毛哥   | 666@qq.com  |
  |  2 |  216 | 阿伟   | NULL        |
  |  3 | 1000 | 王子   | 1000@qq.com |
  |  4 | 1001 | 王紫   | 1001@qq.com |
  |  5 | 1002 | 王梓   | 1002@qq.com |
  +----+------+--------+-------------+
  5 rows in set (0.00 sec)
  ```

- 插入否则更新

  由于 主键 或者 唯一键 对应的值已经存在而导致插入失败。

  可以选择性的进行同步更新操作语法：

  ```sql
  INSERT ... ON DUPLICATE KEY UPDATE
  	column = value [, column = value] ...
  ```

  ```sql
  mysql> select * from students;
  +----+------+--------+-------------+
  | id | sn   | name   | qq          |
  +----+------+--------+-------------+
  |  1 |  666 | 毛哥   | 666@qq.com  |
  |  2 |  216 | 阿伟   | NULL        |
  |  3 | 1000 | 王子   | 1000@qq.com |
  |  4 | 1001 | 王紫   | 1001@qq.com |
  |  5 | 1002 | 王梓   | 1002@qq.com |
  +----+------+--------+-------------+
  5 rows in set (0.00 sec)
  
  mysql> insert into students (id, sn, name, qq) values (5, 1003, '汪梓', '1003@qq.com') on duplicate key update sn=1003, name='汪梓', qq='1003@qq.com';
  Query OK, 2 rows affected (0.02 sec)
  
  mysql> select * from students;
  +----+------+--------+-------------+
  | id | sn   | name   | qq          |
  +----+------+--------+-------------+
  |  1 |  666 | 毛哥   | 666@qq.com  |
  |  2 |  216 | 阿伟   | NULL        |
  |  3 | 1000 | 王子   | 1000@qq.com |
  |  4 | 1001 | 王紫   | 1001@qq.com |
  |  5 | 1003 | 汪梓   | 1003@qq.com |
  +----+------+--------+-------------+
  5 rows in set (0.00 sec)
  ```

  > `-- 0 row affected`: 表中有冲突数据，但冲突数据的值和 update 的值相等
  > `-- 1 row affected`: 表中没有冲突数据，数据被插入
  > `-- 2 row affected`: 表中有冲突数据，并且数据已经被更新

  ```sql
  -- 通过 MySQL 函数获取受到影响的数据行数
  SELECT ROW_COUNT();
  +-------------+
  | ROW_COUNT() |
  +-------------+
  | 2 		  |
  +-------------+
  ```

- 替换

  - 主键 或者 唯一键 没有冲突，则直接插入
  - 主键 或者 唯一键 如果冲突，则删除后再插入

  ```sql
  mysql> select * from students;
  +----+------+--------+-------------+
  | id | sn   | name   | qq          |
  +----+------+--------+-------------+
  |  1 |  666 | 毛哥   | 666@qq.com  |
  |  2 |  216 | 阿伟   | NULL        |
  |  3 | 1000 | 王子   | 1000@qq.com |
  |  4 | 1001 | 王紫   | 1001@qq.com |
  |  5 | 1003 | 汪梓   | 1003@qq.com |
  +----+------+--------+-------------+
  5 rows in set (0.00 sec)
  
  mysql> replace into students (sn, name, qq) values (999, '汪紫', '9876@qq.com');
  Query OK, 1 row affected (0.01 sec)
  
  mysql> select * from students;
  +----+------+--------+-------------+
  | id | sn   | name   | qq          |
  +----+------+--------+-------------+
  |  1 |  666 | 毛哥   | 666@qq.com  |
  |  2 |  216 | 阿伟   | NULL        |
  |  3 | 1000 | 王子   | 1000@qq.com |
  |  4 | 1001 | 王紫   | 1001@qq.com |
  |  5 | 1003 | 汪梓   | 1003@qq.com |
  |  6 |  999 | 汪紫   | 9876@qq.com |
  +----+------+--------+-------------+
  6 rows in set (0.00 sec)
  
  mysql> replace into students (sn, name, qq) values (1003, '汪子', '9876@qq.com');
  Query OK, 3 rows affected (0.01 sec)
  
  mysql> select * from students;
  +----+------+--------+-------------+
  | id | sn   | name   | qq          |
  +----+------+--------+-------------+
  |  1 |  666 | 毛哥   | 666@qq.com  |
  |  2 |  216 | 阿伟   | NULL        |
  |  3 | 1000 | 王子   | 1000@qq.com |
  |  4 | 1001 | 王紫   | 1001@qq.com |
  |  7 | 1003 | 汪子   | 9876@qq.com |
  +----+------+--------+-------------+
  5 rows in set (0.00 sec)
  ```

## 二、Retrieve

- 语法

  ```sql
  SELECT
  	[DISTINCT] {* | {column [, column] ...}
  	[FROM table_name]
  	[WHERE ...]
  	[ORDER BY column [ASC | DESC], ...]
  	LIMIT ...
  ```

- 案例：

  建表：

  ```sql
  mysql> CREATE TABLE exam_result (
      -> id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
      -> name VARCHAR(20) NOT NULL COMMENT '同学姓名',
      -> chinese float DEFAULT 0.0 COMMENT '语文成绩',
      -> math float DEFAULT 0.0 COMMENT '数学成绩',
      -> english float DEFAULT 0.0 COMMENT '英语成绩'
      -> );
  Query OK, 0 rows affected (0.08 sec)
  ```

  插入：

  ```sql
  mysql> INSERT INTO exam_result (name, chinese, math, english) VALUES
      -> ('唐三藏', 67, 98, 56),
      -> ('孙悟空', 87, 78, 77),
      -> ('猪悟能', 88, 98, 90),
      -> ('曹孟德', 82, 84, 67),
      -> ('刘玄德', 55, 85, 45),
      -> ('孙权', 70, 73, 78),
      -> ('宋公明', 75, 65, 30);
  Query OK, 7 rows affected (0.03 sec)
  Records: 7  Duplicates: 0  Warnings: 0
  ```


### 1.select列

- 通常情况下不建议使用`*`进行全列查询

  - 查询得列越多，意味着需要传输得数据量越大
  - 可能会影响到索引的使用

  ```sql
  mysql> select * from exam_result;
  +----+-----------+---------+------+---------+
  | id | name      | chinese | math | english |
  +----+-----------+---------+------+---------+
  |  1 | 唐三藏    |      67 |   98 |      56 |
  |  2 | 孙悟空    |      87 |   78 |      77 |
  |  3 | 猪悟能    |      88 |   98 |      90 |
  |  4 | 曹孟德    |      82 |   84 |      67 |
  |  5 | 刘玄德    |      55 |   85 |      45 |
  |  6 | 孙权      |      70 |   73 |      78 |
  |  7 | 宋公明    |      75 |   65 |      30 |
  +----+-----------+---------+------+---------+
  7 rows in set (0.00 sec)
  ```

### 2.指定列查询

- 指定列的顺序不需要按定义表的顺序来

  ```sql
  mysql> select id, name, english from exam_result;
  +----+-----------+---------+
  | id | name      | english |
  +----+-----------+---------+
  |  1 | 唐三藏    |      56 |
  |  2 | 孙悟空    |      77 |
  |  3 | 猪悟能    |      90 |
  |  4 | 曹孟德    |      67 |
  |  5 | 刘玄德    |      45 |
  |  6 | 孙权      |      78 |
  |  7 | 宋公明    |      30 |
  +----+-----------+---------+
  7 rows in set (0.00 sec)
  ```

- 查询字段为表达式

  - 表达式不包含字段

    ```sql
    mysql> select id, name, 666 from exam_result;
    +----+-----------+-----+
    | id | name      | 666 |
    +----+-----------+-----+
    |  1 | 唐三藏    | 666 |
    |  2 | 孙悟空    | 666 |
    |  3 | 猪悟能    | 666 |
    |  4 | 曹孟德    | 666 |
    |  5 | 刘玄德    | 666 |
    |  6 | 孙权      | 666 |
    |  7 | 宋公明    | 666 |
    +----+-----------+-----+
    7 rows in set (0.00 sec)
    ```

    ```sql
    mysql> select id, name, 666 * 666 from exam_result;
    +----+-----------+-----------+
    | id | name      | 666 * 666 |
    +----+-----------+-----------+
    |  1 | 唐三藏    |    443556 |
    |  2 | 孙悟空    |    443556 |
    |  3 | 猪悟能    |    443556 |
    |  4 | 曹孟德    |    443556 |
    |  5 | 刘玄德    |    443556 |
    |  6 | 孙权      |    443556 |
    |  7 | 宋公明    |    443556 |
    +----+-----------+-----------+
    7 rows in set (0.00 sec)
    ```

  - 表达式包含一个字段

    ```sql
    mysql> select id, name, chinese + 5 from exam_result;
    +----+-----------+-------------+
    | id | name      | chinese + 5 |
    +----+-----------+-------------+
    |  1 | 唐三藏    |          72 |
    |  2 | 孙悟空    |          92 |
    |  3 | 猪悟能    |          93 |
    |  4 | 曹孟德    |          87 |
    |  5 | 刘玄德    |          60 |
    |  6 | 孙权      |          75 |
    |  7 | 宋公明    |          80 |
    +----+-----------+-------------+
    7 rows in set (0.00 sec)
    ```

  - 表达式包含多个字段

    ```sql
    mysql> select id, name, chinese + math + english from exam_result;
    +----+-----------+--------------------------+
    | id | name      | chinese + math + english |
    +----+-----------+--------------------------+
    |  1 | 唐三藏    |                      221 |
    |  2 | 孙悟空    |                      242 |
    |  3 | 猪悟能    |                      276 |
    |  4 | 曹孟德    |                      233 |
    |  5 | 刘玄德    |                      185 |
    |  6 | 孙权      |                      221 |
    |  7 | 宋公明    |                      170 |
    +----+-----------+--------------------------+
    7 rows in set (0.00 sec)
    ```

- 为查询结果指定别名

  语法：

  ```sql
  SELECT column [AS] alias_name [...] FROM table_name;
  ```

  ```sql
  mysql> select id, name, chinese + math + english as 总分 from exam_result;
  +----+-----------+--------+
  | id | name      | 总分   |
  +----+-----------+--------+
  |  1 | 唐三藏    |    221 |
  |  2 | 孙悟空    |    242 |
  |  3 | 猪悟能    |    276 |
  |  4 | 曹孟德    |    233 |
  |  5 | 刘玄德    |    185 |
  |  6 | 孙权      |    221 |
  |  7 | 宋公明    |    170 |
  +----+-----------+--------+
  7 rows in set (0.00 sec)
  ```

  `as`甚至可以省略：

  ```sql
  mysql> select id, name, chinese + math + english 总分 from exam_result;
  +----+-----------+--------+
  | id | name      | 总分   |
  +----+-----------+--------+
  |  1 | 唐三藏    |    221 |
  |  2 | 孙悟空    |    242 |
  |  3 | 猪悟能    |    276 |
  |  4 | 曹孟德    |    233 |
  |  5 | 刘玄德    |    185 |
  |  6 | 孙权      |    221 |
  |  7 | 宋公明    |    170 |
  +----+-----------+--------+
  7 rows in set (0.00 sec)
  ```

- 结果去重

  ```sql
  mysql> select math from exam_result;
  +------+
  | math |
  +------+
  |   98 |
  |   78 |
  |   98 |
  |   84 |
  |   85 |
  |   73 |
  |   65 |
  +------+
  7 rows in set (0.00 sec)
  ```

  98分重复了。

  ```sql
  mysql> select distinct math from exam_result;
  +------+
  | math |
  +------+
  |   98 |
  |   78 |
  |   84 |
  |   85 |
  |   73 |
  |   65 |
  +------+
  6 rows in set (0.00 sec)
  ```

  去重成功

  ```sql
  mysql> select distinct * from exam_result;
  +----+-----------+---------+------+---------+
  | id | name      | chinese | math | english |
  +----+-----------+---------+------+---------+
  |  1 | 唐三藏    |      67 |   98 |      56 |
  |  2 | 孙悟空    |      87 |   78 |      77 |
  |  3 | 猪悟能    |      88 |   98 |      90 |
  |  4 | 曹孟德    |      82 |   84 |      67 |
  |  5 | 刘玄德    |      55 |   85 |      45 |
  |  6 | 孙权      |      70 |   73 |      78 |
  |  7 | 宋公明    |      75 |   65 |      30 |
  +----+-----------+---------+------+---------+
  7 rows in set (0.00 sec)
  ```

  这里没有完全一致的记录，所以没有去重。

### 3.WHERE 条件

#### (1)比较运算符

|      运算符       |                             说明                             |
| :---------------: | :----------------------------------------------------------: |
|   >, >=, <, <=    |                大于，大于等于，小于，小于等于                |
|         =         | 等于，NULL 不安全，例如 NULL = NULL 的结果是 NULL（Mysql中，`=`表示判断相等） |
|        <=>        |     等于，NULL 安全，例如 NULL <=> NULL 的结果是 TRUE(1)     |
|      !=, <>       |                            不等于                            |
| BETWEEN a0 AND a1 |   范围匹配，[a0, a1]，如果 a0 <= value <= a1，返回 TRUE(1)   |
| IN (option, ...)  |           如果是 option 中的任意一个，返回 TRUE(1)           |
|      IS NULL      |                           是 NULL                            |
|    IS NOT NULL    |                          不是 NULL                           |
|       LIKE        | 模糊匹配。% 表示任意多个（包括 0 个）任意字符；_ 表示任意一个字符 |

#### (2)逻辑运算符

| 运算符 |                    说明                    |
| :----: | :----------------------------------------: |
|  AND   | 多个条件必须都为 TRUE(1)，结果才是 TRUE(1) |
|   OR   |   任意一个条件为 TRUE(1), 结果为 TRUE(1)   |
|  NOT   |      条件为 TRUE(1)，结果为 FALSE(0)       |

- `NULL`值的比较

  ```sql
  mysql> select * from student;
  +------+--------+------+
  | id   | name   | tel  |
  +------+--------+------+
  | 0001 | ahwei  | 0110 |
  | 0002 | cat    | 0111 |
  | 0003 | prince | 1000 |
  | 0004 |        | 1001 |
  | 0004 | NULL   | 1001 |
  +------+--------+------+
  5 rows in set (0.00 sec)
  ```

  一般情况下，`NULL`不参与比较：

  ```sql
  mysql> select * from student where name = NULL;
  Empty set (0.00 sec)
  ```

  前面两种对`NULL`无效！

  ```sql
  mysql> select NULL = NULL, NULL != NULL, NULL <=> NULL, NULL is NULL, NULL is not NULL;
  +-------------+--------------+---------------+--------------+------------------+
  | NULL = NULL | NULL != NULL | NULL <=> NULL | NULL is NULL | NULL is not NULL |
  +-------------+--------------+---------------+--------------+------------------+
  |        NULL |         NULL |             1 |            1 |                0 |
  +-------------+--------------+---------------+--------------+------------------+
  1 row in set (0.00 sec)
  ```

  空串不同于`NULL`，可以被查出：

  ```sql
  mysql> select * from student where name = '';
  +------+------+------+
  | id   | name | tel  |
  +------+------+------+
  | 0004 |      | 1001 |
  +------+------+------+
  1 row in set (0.00 sec)
  ```

  如果想要查出`NULL`，用以下两种方式：

  ```sql
  mysql> select * from student where name <=> NULL;
  +------+------+------+
  | id   | name | tel  |
  +------+------+------+
  | 0004 | NULL | 1001 |
  +------+------+------+
  1 row in set (0.00 sec)
  ```

  ```sql
  mysql> select * from student where name is NULL;
  +------+------+------+
  | id   | name | tel  |
  +------+------+------+
  | 0004 | NULL | 1001 |
  +------+------+------+
  1 row in set (0.00 sec)
  ```

  **select可以设置比较条件，使用`where`子句`>`、`>=`、`<`、`<=`、`=`不能用来直接比较`NULL`，但是可以比较`int`或者`string`。如果我们要比较`NULL`，可以使用`<=>`，但更推荐使用`IS NULL`、`IS NOT NULL`。**

- 语文成绩在` [80, 90] `分的同学及语文成绩

  - 使用`and`进行条件连接

    ```sql
    mysql> select name, chinese from exam_result where chinese >= 80 and chinese <= 90;
    +-----------+---------+
    | name      | chinese |
    +-----------+---------+
    | 孙悟空    |      87 |
    | 猪悟能    |      88 |
    | 曹孟德    |      82 |
    +-----------+---------+
    3 rows in set (0.00 sec)
    ```

  - 使用`between...and...`条件

    ```sql
    mysql> select name, chinese from exam_result where chinese between 80 and 90;
    +-----------+---------+
    | name      | chinese |
    +-----------+---------+
    | 孙悟空    |      87 |
    | 猪悟能    |      88 |
    | 曹孟德    |      82 |
    +-----------+---------+
    3 rows in set (0.00 sec)
    ```

- 数学成绩是 58 或者 59 或者 98 或者 99 分的同学及数学成绩

  - 使用 OR 进行条件连接

    ```sql
    mysql> select name, math from exam_result 
        -> where math = 58
        -> or math = 59
        -> or math = 98
        -> or math = 99;
    +-----------+------+
    | name      | math |
    +-----------+------+
    | 唐三藏    |   98 |
    | 猪悟能    |   98 |
    +-----------+------+
    2 rows in set (0.00 sec)
    ```

  - 使用 IN 条件

    ```sql
    mysql> select name, math from exam_result where math in (58, 59, 98, 99);
    +-----------+------+
    | name      | math |
    +-----------+------+
    | 唐三藏    |   98 |
    | 猪悟能    |   98 |
    +-----------+------+
    2 rows in set (0.00 sec)
    ```

- `select`中没有出现的列也可以在`where`里判断

  查找语文不及格的同学的名字和他的数学成绩：

  ```
  mysql> select name, math from exam_result where chinese < 60;
  +-----------+------+
  | name      | math |
  +-----------+------+
  | 刘玄德    |   85 |
  +-----------+------+
  1 row in set (0.00 sec)
  ```

- 模糊匹配

  姓孙的同学 及 孙某同学

  - 姓孙：

    ```sql
    mysql> select name, id from exam_result where name like '孙%';
    +-----------+----+
    | name      | id |
    +-----------+----+
    | 孙悟空    |  2 |
    | 孙权      |  6 |
    +-----------+----+
    2 rows in set (0.00 sec)
    ```

  - 孙某：

    ```sql
    mysql> select name, id from exam_result where name like '孙_';
    +--------+----+
    | name   | id |
    +--------+----+
    | 孙权   |  6 |
    +--------+----+
    1 row in set (0.00 sec)
    ```

  - 孙某某

    ```sql
    mysql> select name, id from exam_result where name like '孙_';
    +--------+----+
    | name   | id |
    +--------+----+
    | 孙权   |  6 |
    +--------+----+
    1 row in set (0.00 sec)
    ```

  - MySQL在当前的`select`执行的时候，顺序是怎样的？

    ![image-20230426162652649](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230426162652649.png)

- WHERE 条件中比较运算符两侧都是字段

  ```sql
  mysql> select name, id, chinese, english from exam_result where chinese > english;
  +-----------+----+---------+---------+
  | name      | id | chinese | english |
  +-----------+----+---------+---------+
  | 唐三藏    |  1 |      67 |      56 |
  | 孙悟空    |  2 |      87 |      77 |
  | 曹孟德    |  4 |      82 |      67 |
  | 刘玄德    |  5 |      55 |      45 |
  | 宋公明    |  7 |      75 |      30 |
  +-----------+----+---------+---------+
  5 rows in set (0.00 sec)
  ```

  Mysql执行过程中的遍历可以理解为：把表中的数据按照`where`子句的要求一行一行的比较，满足条件，留下来，不满足条件，不要了。

- WHERE 条件中使用表达式

  找出总分200以下的学生

  **别名不能用在 WHERE 条件中，因为执行顺序告诉我们，执行`where`的时候前面的`select`根本还没执行！**

  ```sql
  mysql> select name, id, chinese + math + english as total from exam_result where total < 200;
  ERROR 1054 (42S22): Unknown column 'total' in 'where clause'
  ```

  ```sql
  mysql> select name, id, chinese + math + english as total from exam_result where chinese + math + english < 200;
  +-----------+----+-------+
  | name      | id | total |
  +-----------+----+-------+
  | 刘玄德    |  5 |   185 |
  | 宋公明    |  7 |   170 |
  +-----------+----+-------+
  2 rows in set (0.00 sec)
  ```

  **where中也不能取别名，因为别名只是在最后显示前做的，并不会被纳入前期的计算。**

### 4.结果排序

#### (1)语法：

```sql
-- ASC 为升序（从小到大）
-- DESC 为降序（从大到小）			——de是降低的意思
-- 默认为 ASC
SELECT ... FROM table_name [WHERE ...]
ORDER BY column [ASC|DESC], [...];
```

**注意：没有 ORDER BY 子句的查询，返回的顺序是未定义的，永远不要依赖这个顺序**

#### (2)案例：

按数学成绩升序排序：

- 默认升序

  ```sql
  mysql> select name, math from exam_result order by math;
  +-----------+------+
  | name      | math |
  +-----------+------+
  | 宋公明    |   65 |
  | 孙权      |   73 |
  | 孙悟空    |   78 |
  | 曹孟德    |   84 |
  | 刘玄德    |   85 |
  | 唐三藏    |   98 |
  | 猪悟能    |   98 |
  +-----------+------+
  7 rows in set (0.00 sec)
  ```

- 指明升序

  ```sql
  mysql> select name, math from exam_result order by math asc;
  +-----------+------+
  | name      | math |
  +-----------+------+
  | 宋公明    |   65 |
  | 孙权      |   73 |
  | 孙悟空    |   78 |
  | 曹孟德    |   84 |
  | 刘玄德    |   85 |
  | 唐三藏    |   98 |
  | 猪悟能    |   98 |
  +-----------+------+
  7 rows in set (0.00 sec)
  ```

- 指明降序

  ```sql
  mysql> select name, math from exam_result order by math desc;
  +-----------+------+
  | name      | math |
  +-----------+------+
  | 唐三藏    |   98 |
  | 猪悟能    |   98 |
  | 刘玄德    |   85 |
  | 曹孟德    |   84 |
  | 孙悟空    |   78 |
  | 孙权      |   73 |
  | 宋公明    |   65 |
  +-----------+------+
  7 rows in set (0.00 sec)
  ```

##### 学生表，按照名字排序：

- 升序

  ```sql
  mysql> select * from student order by name;
  +------+--------+------+
  | id   | name   | tel  |
  +------+--------+------+
  | 0004 | NULL   | 1001 |
  | 0004 |        | 1001 |
  | 0001 | ahwei  | 0110 |
  | 0002 | cat    | 0111 |
  | 0003 | prince | 1000 |
  +------+--------+------+
  5 rows in set (0.00 sec)
  ```

- 降序

  ```sql
  mysql> select * from student order by name desc;
  +------+--------+------+
  | id   | name   | tel  |
  +------+--------+------+
  | 0003 | prince | 1000 |
  | 0002 | cat    | 0111 |
  | 0001 | ahwei  | 0110 |
  | 0004 |        | 1001 |
  | 0004 | NULL   | 1001 |
  +------+--------+------+
  5 rows in set (0.00 sec)
  ```

  对字符串排序其实是按字典序排，且`NULL`视为比任何值都小。

##### 查询同学各门成绩，依次按数学降序，英语升序，语文升序的方式显示：

```sql
mysql> select name, chinese, math, english from exam_result order by math desc, english asc, chinese asc;
+-----------+---------+------+---------+
| name      | chinese | math | english |
+-----------+---------+------+---------+
| 唐三藏    |      67 |   98 |      56 |
| 猪悟能    |      88 |   98 |      90 |
| 刘玄德    |      55 |   85 |      45 |
| 曹孟德    |      82 |   84 |      67 |
| 孙悟空    |      87 |   78 |      77 |
| 孙权      |      70 |   73 |      78 |
| 宋公明    |      75 |   65 |      30 |
+-----------+---------+------+---------+
7 rows in set (0.00 sec)
```

**多字段排序，排序优先级随书写顺序**

##### 查询同学及总分，由高到低：

- `order by`中可以使用表达式

  ```sql
  mysql> select name, chinese + math + english from exam_result order by chinese + math + english desc;
  +-----------+--------------------------+
  | name      | chinese + math + english |
  +-----------+--------------------------+
  | 猪悟能    |                      276 |
  | 孙悟空    |                      242 |
  | 曹孟德    |                      233 |
  | 唐三藏    |                      221 |
  | 孙权      |                      221 |
  | 刘玄德    |                      185 |
  | 宋公明    |                      170 |
  +-----------+--------------------------+
  7 rows in set (0.00 sec)
  ```

- `ORDER BY` 子句中可以使用列别名

  ```sql
  mysql> select name, chinese + math + english as total from exam_result order by total;
  +-----------+-------+
  | name      | total |
  +-----------+-------+
  | 宋公明    |   170 |
  | 刘玄德    |   185 |
  | 唐三藏    |   221 |
  | 孙权      |   221 |
  | 曹孟德    |   233 |
  | 孙悟空    |   242 |
  | 猪悟能    |   276 |
  +-----------+-------+
  7 rows in set (0.00 sec)
  ```

  这里为什么可以使用别名呢？

  ![image-20230426172856966](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230426172856966.png)

  所谓的排序，必须得先有结果。所以它是在显示前排序的，即上图中还应有第五步来排序。

### 5.筛选分页结果

**语法：**

```sql
-- 起始下标为 0
-- 从 0 开始，筛选 n 条结果
SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT n;
-- 从 s 开始，筛选 n 条结果
SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT s, n;
-- 从 s 开始，筛选 n 条结果，比第二种用法更明确，建议使用
SELECT ... FROM table_name [WHERE ...] [ORDER BY ...] LIMIT n OFFSET s;
```

显示总分前三的同学：

```sql
mysql> select name, chinese + math + english as total from exam_result order by total limit 3;
+-----------+-------+
| name      | total |
+-----------+-------+
| 宋公明    |   170 |
| 刘玄德    |   185 |
| 唐三藏    |   221 |
+-----------+-------+
3 rows in set (0.00 sec)
```

`limit`一般也是更加靠后执行：

```sql
mysql> select name, chinese + math + english as total from exam_result limit 3 order by total;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'order by total' at line 1
```

把所有同学按照总分分页查询：

```sql
mysql> select name, chinese + math + english as total from exam_result order by total limit 3 offset 0;
+-----------+-------+
| name      | total |
+-----------+-------+
| 宋公明    |   170 |
| 刘玄德    |   185 |
| 唐三藏    |   221 |
+-----------+-------+
3 rows in set (0.00 sec)

mysql> select name, chinese + math + english as total from exam_result order by total limit 3 offset 3;
+-----------+-------+
| name      | total |
+-----------+-------+
| 孙权      |   221 |
| 曹孟德    |   233 |
| 孙悟空    |   242 |
+-----------+-------+
3 rows in set (0.00 sec)

mysql> select name, chinese + math + english as total from exam_result order by total limit 3 offset 6;
+-----------+-------+
| name      | total |
+-----------+-------+
| 猪悟能    |   276 |
+-----------+-------+
1 row in set (0.00 sec)
```

## 三、Update

### 1.语法：

```sql
UPDATE table_name SET column = expr [, column = expr ...]
	[WHERE ...] [ORDER BY ...] [LIMIT ...]
```

**对查询到的结果进行列值更新**

### 2.案例：

- 更新为具体值

  ```sql
  -- 查看原始数据
  mysql> select name, math from exam_result where name = '孙悟空';
  +-----------+------+
  | name      | math |
  +-----------+------+
  | 孙悟空    |   78 |
  +-----------+------+
  1 row in set (0.00 sec)
  -- 数据更新
  mysql> update exam_result set math = 80 where name = '孙悟空';
  Query OK, 1 row affected (0.02 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  -- 查看更新后数据
  mysql> select name, math from exam_result where name = '孙悟空';
  +-----------+------+
  | name      | math |
  +-----------+------+
  | 孙悟空    |   80 |
  +-----------+------+
  1 row in set (0.00 sec)
  ```

- 一次更新多个列

  ```sql
  -- 查看原始数据
  mysql> select name, math, chinese from exam_result where name = '曹孟德';
  +-----------+------+---------+
  | name      | math | chinese |
  +-----------+------+---------+
  | 曹孟德    |   84 |      82 |
  +-----------+------+---------+
  1 row in set (0.00 sec)
  -- 数据更新
  mysql> update exam_result set math = 60, chinese = 70 where name = '曹孟德';
  Query OK, 1 row affected (0.01 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  -- 查看更新后数据
  mysql> select name, math, chinese from exam_result where name = '曹孟德';
  +-----------+------+---------+
  | name      | math | chinese |
  +-----------+------+---------+
  | 曹孟德    |   60 |      70 |
  +-----------+------+---------+
  1 row in set (0.00 sec)
  ```

- 更新值为原值基础上变更

  **将总成绩倒数前三的3位同学的数学成绩加上 30 分**

  ```sql
  -- 查看原数据
  mysql> select name, chinese + math + english as total from exam_result order by total asc limit 3;
  +-----------+-------+
  | name      | total |
  +-----------+-------+
  | 宋公明    |   170 |
  | 刘玄德    |   185 |
  | 曹孟德    |   197 |
  +-----------+-------+
  3 rows in set (0.00 sec)
  -- 数据更新，不支持 math += 30 这种语法
  mysql> update exam_result set math = math + 30 order by chinese + math + english asc limit 3;
  Query OK, 3 rows affected (0.01 sec)
  Rows matched: 3  Changed: 3  Warnings: 0
  -- 查看更新后数据
  mysql> select name, math, chinese + math + english as total from exam_result where name in ('宋公明', '刘玄德', '曹孟德');
  +-----------+------+-------+
  | name      | math | total |
  +-----------+------+-------+
  | 曹孟德    |   90 |   227 |
  | 刘玄德    |  115 |   215 |
  | 宋公明    |   95 |   200 |
  +-----------+------+-------+
  3 rows in set (0.00 sec)
  ```

  **是否可以给总分+30？**

  ——`update`只能修改表列数据！只能在显示的时候+30。

- 没有 WHERE 子句，则更新全表

  **注意：更新全表的语句慎用！**

  ```sql
  -- 查看原数据
  mysql> select name, chinese from exam_result;
  +-----------+---------+
  | name      | chinese |
  +-----------+---------+
  | 唐三藏    |      67 |
  | 孙悟空    |      87 |
  | 猪悟能    |      88 |
  | 曹孟德    |      70 |
  | 刘玄德    |      55 |
  | 孙权      |      70 |
  | 宋公明    |      75 |
  +-----------+---------+
  7 rows in set (0.00 sec)
  -- 数据更新
  mysql> update exam_result set chinese = chinese * 2;
  Query OK, 7 rows affected (0.01 sec)
  Rows matched: 7  Changed: 7  Warnings: 0
  -- 查看更新后数据
  mysql> select name, chinese from exam_result;
  +-----------+---------+
  | name      | chinese |
  +-----------+---------+
  | 唐三藏    |     134 |
  | 孙悟空    |     174 |
  | 猪悟能    |     176 |
  | 曹孟德    |     140 |
  | 刘玄德    |     110 |
  | 孙权      |     140 |
  | 宋公明    |     150 |
  +-----------+---------+
  7 rows in set (0.00 sec)
  ```

## 四、Delete

### 1.删除数据

#### (1)语法

```sql
DELETE FROM table_name [WHERE ...] [ORDER BY ...] [LIMIT ...]
```

#### (2)案例

删除数据，是按照记录来的，一删就是一行。

```sql
mysql> delete from exam_result order by chinese + math + english asc limit 3;
Query OK, 3 rows affected (0.01 sec)

mysql> select * from exam_result;
+----+-----------+---------+------+---------+
| id | name      | chinese | math | english |
+----+-----------+---------+------+---------+
|  2 | 孙悟空    |     174 |   80 |      77 |
|  3 | 猪悟能    |     176 |   98 |      90 |
|  4 | 曹孟德    |     140 |   90 |      67 |
|  6 | 孙权      |     140 |   73 |      78 |
+----+-----------+---------+------+---------+
4 rows in set (0.00 sec)
```

从删库到跑路。

**删除数据前一定一定要想清楚了。**

```sql
mysql> delete from exam_result;
Query OK, 4 rows affected (0.00 sec)

mysql> select * from exam_result;
Empty set (0.00 sec)
```

删除时的细节：

- 自增长不会被删除，所以即使把整张表删除了，下次再插入时，还是按照上一次插入的值的自增长继续加一。

### 2.截断表

#### (1)语法

```sql
TRUNCATE [TABLE] table_name
```

**注意：这个操作慎用**
1. 只能对整表操作，不能像`DELETE`一样针对部分数据操作；
2. 实际上`MySQL`不对数据操作，所以比`DELETE`更快，但是`TRUNCATE`在删除数据的时候，并不经过真正的事物，所以无法回滚;
3. 会重置`AUTO_INCREMENT`项

#### (2)案例

```sql
-- 建表
mysql> CREATE TABLE for_truncate (
    -> id INT PRIMARY KEY AUTO_INCREMENT,
    -> name VARCHAR(20)
    -> );
Query OK, 0 rows affected (0.04 sec)
-- 插入数据
mysql> INSERT INTO for_truncate (name) VALUES ('A'), ('B'), ('C');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM for_truncate;
+----+------+
| id | name |
+----+------+
|  1 | A    |
|  2 | B    |
|  3 | C    |
+----+------+
3 rows in set (0.00 sec)
-- 查看建表语句，这时自增长是4
mysql> show create table for_truncate;
+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table        | Create Table                                                                                                                                                                                                  |
+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| for_truncate | CREATE TABLE `for_truncate` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
+--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
-- 清空表
mysql> truncate for_truncate;
Query OK, 0 rows affected (0.08 sec)

mysql> select * from for_truncate;
Empty set (0.00 sec)
-- 查看建表数据，这时自增长被重置了
mysql> show create table for_truncate;
+--------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table        | Create Table                                                                                                                                                                                 |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| for_truncate | CREATE TABLE `for_truncate` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
-- 再次插入数据
mysql> insert into for_truncate (name) values ('a');
Query OK, 1 row affected (0.01 sec)
-- 自增长确实从1开始
mysql> select * from for_truncate;
+----+------+
| id | name |
+----+------+
|  1 | a    |
+----+------+
1 row in set (0.01 sec)
```

## 五、插入查询结果

### 1.语法

```sql
INSERT INTO table_name [(column [, column ...])] SELECT ...
```

### 2.案例：

**删除表中的的重复复记录，重复的数据只能有一份**

```sql
-- 创建原数据表
CREATE TABLE duplicate_table (id int, name varchar(20));
Query OK, 0 rows affected (0.01 sec)
-- 插入测试数据
INSERT INTO duplicate_table VALUES
(100, 'aaa'),
(100, 'aaa'),
(200, 'bbb'),
(200, 'bbb'),
(200, 'bbb'),
(300, 'ccc');
Query OK, 6 rows affected (0.00 sec)
Records: 6 Duplicates: 0 Warnings: 0
```

```sql
-- 创建一张空表 no_duplicate_table，结构和 duplicate_table 一样
CREATE TABLE no_duplicate_table LIKE duplicate_table;
Query OK, 0 rows affected (0.00 sec)
```

```sql
-- 将 duplicate_table 的去重数据插入到 no_duplicate_table
INSERT INTO no_duplicate_table SELECT DISTINCT * FROM duplicate_table;
Query OK, 3 rows affected (0.00 sec)
Records: 3 Duplicates: 0 Warnings: 0
-- 通过重命名表，实现原子的去重操作
RENAME TABLE duplicate_table TO old_duplicate_table,
no_duplicate_table TO duplicate_table;
Query OK, 0 rows affected (0.00 sec)
-- 查看最终结果
SELECT * FROM duplicate_table;
+------+------+
| id | name |
+------+------+
| 100 | aaa |
| 200 | bbb |
| 300 | ccc |
+------+------+
3 rows in set (0.00 sec)
```

## 六、聚合函数

|           函数           |                    说明                     |
| :----------------------: | :-----------------------------------------: |
| `COUNT([DISTINCT] expr)` |           返回查询到的数据的数量            |
|  `SUM([DISTINCT] expr)`  |  返回查询到的数据的 总和，不是数字没有意义  |
| `AVG([DISTINCT] expr) `  | 返回查询到的数据的 平均值，不是数字没有意义 |
|  `MAX([DISTINCT] expr)`  | 返回查询到的数据的 最大值，不是数字没有意义 |
|  `MIN([DISTINCT] expr)`  | 返回查询到的数据的 最小值，不是数字没有意义 |

- `count`是否受到`NULL`影响

  ```sql
  mysql> select * from test;
  +------+--------+
  | id   | name   |
  +------+--------+
  |    7 | 张三   |
  |    1 | 张四   |
  | NULL | NULL   |
  |    8 | 赵六   |
  +------+--------+
  4 rows in set (0.00 sec)
  
  -- count(*)不受NULL影响
  mysql> select count(*) from test;
  +----------+
  | count(*) |
  +----------+
  |        4 |
  +----------+
  1 row in set (0.00 sec)
  
  -- count(普通字段)受NULL影响，NULL不会计入统计结果
  mysql> select count(id) from test;
  +-----------+
  | count(id) |
  +-----------+
  |         3 |
  +-----------+
  1 row in set (0.00 sec)
  
  mysql> select count(name) from test;
  +-------------+
  | count(name) |
  +-------------+
  |           3 |
  +-------------+
  1 row in set (0.00 sec)
  
  mysql> select count(1) from test;
  +----------+
  | count(1) |
  +----------+
  |        4 |
  +----------+
  1 row in set (0.00 sec)
  
  
  -- select可以独立地执行表达式，并拼在表的右侧
  mysql> select name, 6*6 from test;
  +--------+-----+
  | name   | 6*6 |
  +--------+-----+
  | 张三   |  36 |
  | 张四   |  36 |
  | NULL   |  36 |
  | 赵六   |  36 |
  +--------+-----+
  4 rows in set (0.00 sec)
  -- 所以count(表达式),就相当于是对那一列做聚合，即统计出表有多少行，不会受到NULL的影响
  ```

- 去重位置的影响

  ```sql
  mysql> select distinct count(math) from exam_result;
  +-------------+
  | count(math) |
  +-------------+
  |           7 |
  +-------------+
  1 row in set (0.00 sec)
  
  mysql> select count(distinct math) from exam_result;
  +----------------------+
  | count(distinct math) |
  +----------------------+
  |                    6 |
  +----------------------+
  1 row in set (0.00 sec)
  ```

  和执行顺序有关！

- 聚合函数

  聚合统计一定是直接或间接统计列方向上的某些数据（一定是相同属性的）。而且要聚合，必须先拿到这一列的数据。

## 七、group by子句的使用

以前`select`的时候，都是将数据作为一个整体，其实，`mysql`可以支持按照指定的列进行对数据分组，我们可以让特定的`sql`在特定的组内进行某种操作。

在`select`中使用`group by`子句可以对指定列进行分组查询

```sql
select column1, column2, .. from table group by column;
```

```sql
mysql> select * from emp;
+--------+--------+-----------+------+---------------------+---------+---------+--------+
| empno  | ename  | job       | mgr  | hiredate            | sal     | comm    | deptno |
+--------+--------+-----------+------+---------------------+---------+---------+--------+
| 007369 | SMITH  | CLERK     | 7902 | 1980-12-17 00:00:00 |  800.00 |    NULL |     20 |
| 007499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 00:00:00 | 1600.00 |  300.00 |     30 |
| 007521 | WARD   | SALESMAN  | 7698 | 1981-02-22 00:00:00 | 1250.00 |  500.00 |     30 |
| 007566 | JONES  | MANAGER   | 7839 | 1981-04-02 00:00:00 | 2975.00 |    NULL |     20 |
| 007654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 00:00:00 | 1250.00 | 1400.00 |     30 |
| 007698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 00:00:00 | 2850.00 |    NULL |     30 |
| 007782 | CLARK  | MANAGER   | 7839 | 1981-06-09 00:00:00 | 2450.00 |    NULL |     10 |
| 007788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 00:00:00 | 3000.00 |    NULL |     20 |
| 007839 | KING   | PRESIDENT | NULL | 1981-11-17 00:00:00 | 5000.00 |    NULL |     10 |
| 007844 | TURNER | SALESMAN  | 7698 | 1981-09-08 00:00:00 | 1500.00 |    0.00 |     30 |
| 007876 | ADAMS  | CLERK     | 7788 | 1987-05-23 00:00:00 | 1100.00 |    NULL |     20 |
| 007900 | JAMES  | CLERK     | 7698 | 1981-12-03 00:00:00 |  950.00 |    NULL |     30 |
| 007902 | FORD   | ANALYST   | 7566 | 1981-12-03 00:00:00 | 3000.00 |    NULL |     20 |
| 007934 | MILLER | CLERK     | 7782 | 1982-01-23 00:00:00 | 1300.00 |    NULL |     10 |
+--------+--------+-----------+------+---------------------+---------+---------+--------+
14 rows in set (0.00 sec)

mysql> select * from dept;
+--------+------------+----------+
| deptno | dname      | loc      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+
4 rows in set (0.00 sec)

mysql> select * from salgrade;
+-------+-------+-------+
| grade | losal | hisal |
+-------+-------+-------+
|     1 |   700 |  1200 |
|     2 |  1201 |  1400 |
|     3 |  1401 |  2000 |
|     4 |  2001 |  3000 |
|     5 |  3001 |  9999 |
+-------+-------+-------+
5 rows in set (0.00 sec)
```

- 显示每个部门的平均工资和最高工资

  ```sql
  mysql> select deptno 部门编号, avg(sal) 平均工资, max(sal) 最高工资 from emp group by deptno;
  +--------------+--------------+--------------+
  | 部门编号     | 平均工资     | 最高工资     |
  +--------------+--------------+--------------+
  |           20 |  2175.000000 |      3000.00 |
  |           30 |  1566.666667 |      2850.00 |
  |           10 |  2916.666667 |      5000.00 |
  +--------------+--------------+--------------+
  3 rows in set (0.00 sec)
  ```

- 显示每个部门的每种岗位的平均工资和最低工资

  ​																																					                      先按部门分组，再按工作分组

  ```sql
  mysql> select deptno, job, avg(sal) as 平钧工资, min(sal) as 最低工资 from emp group by deptno, job;
  +--------+-----------+--------------+--------------+
  | deptno | job       | 平钧工资     | 最低工资     |
  +--------+-----------+--------------+--------------+
  |     20 | CLERK     |   950.000000 |       800.00 |
  |     30 | SALESMAN  |  1400.000000 |      1250.00 |
  |     20 | MANAGER   |  2975.000000 |      2975.00 |
  |     30 | MANAGER   |  2850.000000 |      2850.00 |
  |     10 | MANAGER   |  2450.000000 |      2450.00 |
  |     20 | ANALYST   |  3000.000000 |      3000.00 |
  |     10 | PRESIDENT |  5000.000000 |      5000.00 |
  |     30 | CLERK     |   950.000000 |       950.00 |
  |     10 | CLERK     |  1300.000000 |      1300.00 |
  +--------+-----------+--------------+--------------+
  9 rows in set (0.00 sec)
  ```

  尝试把姓名也拼在前面：

  ```sql
  mysql> select ename, deptno, job, avg(sal) as 平钧工资, min(sal) as 最低工资 from emp group by deptno, job;
  ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'scott.emp.ename' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
  ```

  **除了聚合函数，`select`后面可以查的，必须在分组中出现过。**

- 显示平均工资低于2000的部门和它的平均工资

  尝试用`where`子句来筛选：

  ```sql
  mysql> select avg(sal) as 平均工资 from emp group by deptno where 平均工资 < 2000;
  ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'where 平均工资 < 2000' at line 1
  ```

  `where`子句在比较靠前的位置执行，那时还没有进行聚合统计，所以会报错。

  `having`和`group by`配合使用，对`group by`结果进行过滤

  ```sql
  mysql> select avg(sal) as 平均工资 from emp group by deptno having 平均工资 < 2000;
  +--------------+
  | 平均工资     |
  +--------------+
  |  1566.666667 |
  +--------------+
  1 row in set (0.00 sec)
  ```

  执行顺序：**`having`子句是对聚合统计之后的结果进行筛选**

  ```mermaid
  graph LR
  a["from emp"]
  b["group by deptno"]
  c["deptno, avg(sal)[聚合统计]"]
  d["having 平均工资 < 2000"]
  a-->b
  b-->c
  c-->d
  ```

- 下面这条`sql`语句的执行顺序是什么？

  ```sql
  mysql> select deptno, avg(sal) as 平均工资 from emp where sal > 1000 group by deptno having 平均工资 < 2000;
  +--------+--------------+
  | deptno | 平均工资      |
  +--------+--------------+
  |     30 |  1690.000000 |
  +--------+--------------+
  1 row in set (0.00 sec)
  ```

  ```mermaid
  graph LR
  a["from emp"]
  a1["where sal > 1000"]
  b["group by deptno"]
  c["deptno, avg(sal)[聚合统计]"]
  d["having 平均工资 < 2000"]
  a-->a1
  a1-->b
  b-->c
  c-->d
  ```

  > 1.`group by`是通过分组这样的手段，为未来进行聚合统计提供基本的功能支持（`group by`一定是配合聚合统计使用的）。
  >
  > 2.`group by`后面跟的都是分组的字段依据，只有在`group by`后面出现的字段，未来在聚合统计的时候，在`select`中才能出现。
  >
  > 3.`having`后面出现的，必须在`select`中出现过。
  >
  > 3.`where`与`having`：他们两个不是冲突的，是互相补充的。
  >
  > - `having`：通常是在完成整个分组聚合统计，然后再进行筛选；
  > - `where`：通常是在表中数据初步被筛选的时候，要起效果的。

- SQL查询中各个关键字的执行先后顺序 

  > from > on > join > where > group by > with > having > select > distinct > order by > limit
