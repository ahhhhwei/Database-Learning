# 表的约束

真正约束字段的是数据类型，但是数据类型约束很单一，需要有一些额外的约束，更好的保证数据的合法性，从业务逻辑角度保证数据的正确性。比如有一个字段是email，要求是唯一的。
表的约束很多，这里主要介绍如下几个： `null/not null,default, comment, zerofill，primarykey，auto_increment，unique key `。

## 一、空属性

- 两个值：null（默认的）和not null(不为空)
- 数据库默认字段基本都是字段为空，但是实际开发时，尽可能保证字段不为空，因为数据为空没办法参与运算。

建表：

```sql
mysql> create table if not exists `myclass`(
    -> class_name varchar(20) not null,
    -> class_room varchar(20) not null
    -> )engine=InnoDB default charset=utf8;
Query OK, 0 rows affected, 1 warning (0.05 sec)

mysql> desc myclass;
+------------+-------------+------+-----+---------+-------+
| Field      | Type        | Null | Key | Default | Extra |
+------------+-------------+------+-----+---------+-------+
| class_name | varchar(20) | NO   |     | NULL    |       |
| class_room | varchar(20) | NO   |     | NULL    |       |
+------------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```

插入：

```sql
mysql> insert into myclass values ('大数据分析2101', '广B208');
Query OK, 1 row affected (0.02 sec)

mysql> insert into myclass values ('网络工程2101', '阳光厅');
Query OK, 1 row affected (0.02 sec)
```

```sql
mysql> select * from myclass;
+---------------------+------------+
| class_name          | class_room |
+---------------------+------------+
| 大数据分析2101      | 广B208     |
| 网络工程2101        | 阳光厅     |
+---------------------+------------+
2 rows in set (0.00 sec)
```

插入失败：

```sql
mysql> insert into myclass (class_name) values ('网络工程2101');
ERROR 1364 (HY000): Field 'class_room' doesn't have a default value
```

```sql
mysql> insert into myclass values ('网络工程2101', NULL);
ERROR 1048 (23000): Column 'class_room' cannot be null
```

虽然不能插入空，但是可以插入空串：

```sql
mysql> insert into myclass values ('网络工程2102', '');
Query OK, 1 row affected (0.01 sec)

mysql> select * from myclass;
+---------------------+------------+
| class_name          | class_room |
+---------------------+------------+
| 大数据分析2101      | 广B208     |
| 网络工程2101        | 阳光厅     |
| 网络工程2102        |            |
+---------------------+------------+
3 rows in set (0.00 sec)
```

## 二、默认值

默认值：某一种数据会经常性的出现某个具体的值，可以在一开始就指定好，在需要真实数据的时候，用户可以选择性的使用默认值。

建表：

```sql
mysql> create table if not exists t11(
    -> name varchar(20) not null,
    -> age tinyint unsigned default 18,
    -> gender char(2) default '男'
    -> );
Query OK, 0 rows affected (0.07 sec)

mysql> desc t11;
+--------+------------------+------+-----+---------+-------+
| Field  | Type             | Null | Key | Default | Extra |
+--------+------------------+------+-----+---------+-------+
| name   | varchar(20)      | NO   |     | NULL    |       |
| age    | tinyint unsigned | YES  |     | 18      |       |
| gender | char(2)          | YES  |     | 男      |       |
+--------+------------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

插入：

```sql
mysql> insert into t11 (name) values ('阿伟');
Query OK, 1 row affected (0.02 sec)

mysql> select * from t11;
+--------+------+--------+
| name   | age  | gender |
+--------+------+--------+
| 阿伟   |   18 | 男      |
+--------+------+--------+
1 row in set (0.00 sec)
```

**注意：只有设置了default的列，才可以在插入值的时候，对列进行省略**

再看一个例子

建表：

```sql
mysql> create table t12(
    -> name varchar(20) not null,
    -> age int not null default 18
    -> );
Query OK, 0 rows affected (0.12 sec)

mysql> desc t12;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| name  | varchar(20) | NO   |     | NULL    |       |
| age   | int         | NO   |     | 18      |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```

插入：

```sql
mysql> insert into t12 values ('阿伟', 100);
Query OK, 1 row affected (0.02 sec)

mysql> insert into t12 values ('阿伟', NULL);
ERROR 1048 (23000): Column 'age' cannot be null
mysql> insert into t12 (name) values ('阿伟');
Query OK, 1 row affected (0.02 sec)

mysql> select * from t12;
+--------+-----+
| name   | age |
+--------+-----+
| 阿伟   | 100 |
| 阿伟   |  18 |
+--------+-----+
2 rows in set (0.00 sec)
```

只有显式的`NULL`时才会插入失败！

## 三、列描述

列描述：comment，没有实际含义，专门用来描述字段，会根据表创建语句保存，用来给程序员或DBA来进行了解。

```sql
mysql> create table t14( 
    -> name varchar(20) NOT NULL, 
    -> age tinyint(4) DEFAULT '18' comment '这里是用户年龄', 
    -> gender char(1) NOT NULL DEFAULT '男' comment '这里是用户性别'
)ENGINE=innoDB DEFAULT CHARSET=utf8;
```

通过`desc`查看不到注释信息：

```sql
mysql> desc t14;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| name   | varchar(20) | NO   |     | NULL    |       |
| age    | tinyint     | YES  |     | 18      |       |
| gender | char(1)     | NO   |     | 男      |       |
+--------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

通过`show`可以看到：

```sql
mysql> show create table t12\G
*************************** 1. row ***************************
       Table: t12
Create Table: CREATE TABLE `t12` (
  `name` varchar(20) NOT NULL,
  `age` int NOT NULL DEFAULT '18'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.01 sec)
```

## 四、zerofill

```sql
mysql> create table if not exists `t15`(
    -> a int not null,
    -> b int unsigned not null
    -> );
Query OK, 0 rows affected (0.10 sec)

mysql> desc t15;
+-------+------------------+------+-----+---------+-------+
| Field | Type             | Null | Key | Default | Extra |
+-------+------------------+------+-----+---------+-------+
| a     | int(11)      	   | NO   |     | NULL    |       |
| b     | int(10) unsigned | NO   |     | NULL    |       |
+-------+------------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```

可以看到`int(10)`,这个代表什么意思呢？整型不是4字节码？这个10又代表什么呢？其实没有`zerofill`这个属性，括号内的数字是毫无意义的。a和b列就是前面插入的数据，如下：

```sql
mysql> alter table t15 modify a int(5) unsigned zerofill;
```

```sql
mysql> select * from t15;
+-------+---+
| a     | b |
+-------+---+
| 00001 | 2 |
+-------+---+
1 row in set (0.00 sec)
```

这次可以看到a的值由原来的1变成00001，这就是`zerofill`属性的作用，如果宽度小于设定的宽度（这里设置的是5），自动填充0。要注意的是，这只是最后显示的结果，在`MySQL`中实际存储的还是1。为什么是这样呢？我们可以用hex函数来证明。

```sql
mysql> select a, hex(a) from t15;
+-------+--------+
| a     | hex(a) |
+-------+--------+
| 00001 | 1      |
+-------+--------+
1 row in set (0.01 sec)
```

可以看出数据库内部存储的还是1,00001只是设置了`zerofill`属性后的一种格式化输出而已。

## 五、主键

主键：`primary key`用来唯一的约束该字段里面的数据，不能重复，不能为空，一张表中最多只能有一个
主键；主键所在的列通常是整数类型

在一张表中，一行称作一条记录，一列称作一个属性。

案例：

```sql
mysql> create table if not exists t16 (
    -> id int unsigned primary key comment '学生的学号是主键',
    -> name varchar(20) not null
    -> );
Query OK, 0 rows affected (0.06 sec)

mysql> desc t16;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int unsigned | NO   | PRI | NULL    |       |
| name  | varchar(20)  | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```

```sql
mysql> insert into t16 (id, name) values (1, '张三');
Query OK, 1 row affected (0.02 sec)

mysql> insert into t16 (id, name) values (2, '李四');
Query OK, 1 row affected (0.01 sec)

mysql> insert into t16 (id, name) values (3, '李四');
Query OK, 1 row affected (0.02 sec)

mysql> select * from t16;
+----+--------+
| id | name   |
+----+--------+
|  1 | 张三   |
|  2 | 李四   |
|  3 | 李四   |
+----+--------+
3 rows in set (0.00 sec)
# 主键约束：主键对应的字段中不能重复，一旦重复，操作失败。
mysql> insert into t16 (id, name) values (3, '李四');
ERROR 1062 (23000): Duplicate entry '3' for key 't16.PRIMARY'
mysql> insert into t16 (id, name) values (3, '王五');
ERROR 1062 (23000): Duplicate entry '3' for key 't16.PRIMARY'
```

- 删除主键

  ```sql
  alter table 表名 drop primary key;
  ```

  ```sql
  mysql> desc t16;
  +-------+--------------+------+-----+---------+-------+
  | Field | Type         | Null | Key | Default | Extra |
  +-------+--------------+------+-----+---------+-------+
  | id    | int unsigned | NO   | PRI | NULL    |       |
  | name  | varchar(20)  | NO   |     | NULL    |       |
  +-------+--------------+------+-----+---------+-------+
  2 rows in set (0.00 sec)
  
  mysql> alter table t16 drop primary key;
  Query OK, 3 rows affected (0.25 sec)
  Records: 3  Duplicates: 0  Warnings: 0
  
  mysql> desc t16;
  +-------+--------------+------+-----+---------+-------+
  | Field | Type         | Null | Key | Default | Extra |
  +-------+--------------+------+-----+---------+-------+
  | id    | int unsigned | NO   |     | NULL    |       |
  | name  | varchar(20)  | NO   |     | NULL    |       |
  +-------+--------------+------+-----+---------+-------+
  2 rows in set (0.01 sec)
  ```

- 当表创建好以后但是没有主键的时候，可以再次追加主键

  ```sql
  alter table 表名 add primary key(字段列表)
  ```

  ```sql
  mysql> alter table t16 add primary key(id);
  Query OK, 0 rows affected (0.14 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  mysql> desc t16;
  +-------+--------------+------+-----+---------+-------+
  | Field | Type         | Null | Key | Default | Extra |
  +-------+--------------+------+-----+---------+-------+
  | id    | int unsigned | NO   | PRI | NULL    |       |
  | name  | varchar(20)  | NO   |     | NULL    |       |
  +-------+--------------+------+-----+---------+-------+
  2 rows in set (0.00 sec)
  ```

复合主键：在创建表的时候，在所有字段之后，使用primary key(主键字段列表)来创建主键，如果有多个字段作为主键，可以使用复合主键。

```sql
mysql> create table if not exists t17(
    -> id varchar(20),
    -> course varchar(30) comment '课程代码',
    -> score tinyint unsigned default 60 comment '特定id学生在特定course中的得分',
    -> primary key(id, course)
    -> );
Query OK, 0 rows affected (0.11 sec)

mysql> desc t17;
+--------+------------------+------+-----+---------+-------+
| Field  | Type             | Null | Key | Default | Extra |
+--------+------------------+------+-----+---------+-------+
| id     | varchar(20)      | NO   | PRI | NULL    |       |
| course | varchar(30)      | NO   | PRI | NULL    |       |
| score  | tinyint unsigned | YES  |     | 60      |       |
+--------+------------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

如何设计主键？

- 结合你的业务，我们可以选择一个唯一的列属性作为主键。
- 选择与业务无关的唯一值（特定设计的），这样设计，主键值和业务无关，业务调整，不影响主键的表结构。

## 六、自增长

`auto_increment`：当对应的字段，不给值，会自动的被系统触发，系统会从当前字段中已经有的最大值+1操作，得到一个新的不同的值。通常和主键搭配使用，作为逻辑主键。
**自增长的特点：**

- 任何一个字段要做自增长，前提是本身是一个索引（`key`一栏有值）
- 自增长字段必须是整数
- 一张表最多只能有一个自增长

```sql
mysql> create table if not exists t18(
    -> id int unsigned primary key auto_increment,
    -> name varchar(20) not null
    -> );
Query OK, 0 rows affected (0.05 sec)

mysql> desc t18;
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| id    | int unsigned | NO   | PRI | NULL    | auto_increment |
| name  | varchar(20)  | NO   |     | NULL    |                |
+-------+--------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)
```

自增效果：

```sql
mysql> insert into t18 (name) values ('阿伟');
Query OK, 1 row affected (0.01 sec)

mysql> insert into t18 (name) values ('阿伟');
Query OK, 1 row affected (0.02 sec)

mysql> insert into t18 (name) values ('阿伟');
Query OK, 1 row affected (0.01 sec)

mysql> insert into t18 (name) values ('阿伟');
Query OK, 1 row affected (0.01 sec)

mysql> insert into t18 (name) values ('阿伟');
Query OK, 1 row affected (0.01 sec)

mysql> select * from t18;
+----+--------+
| id | name   |
+----+--------+
|  1 | 阿伟   |
|  2 | 阿伟   |
|  3 | 阿伟   |
|  4 | 阿伟   |
|  5 | 阿伟   |
+----+--------+
5 rows in set (0.00 sec)
```

在插入后获取上次插入的 AUTO_INCREMENT 的值（批量插入获取的是第一个值）

```sql
mysql> show create table t18\G
*************************** 1. row ***************************
       Table: t18
Create Table: CREATE TABLE `t18` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)
```

```sql
mysql> insert into t18 (id, name) values (1000, '阿伟');
Query OK, 1 row affected (0.02 sec)

mysql> insert into t18 (id, name) values (9999, '阿伟');
Query OK, 1 row affected (0.01 sec)

mysql> insert into t18 (name) values ('阿伟');
Query OK, 1 row affected (0.01 sec)

mysql> select * from t18;
+-------+--------+
| id    | name   |
+-------+--------+
|     1 | 阿伟   |
|     2 | 阿伟   |
|     3 | 阿伟   |
|     4 | 阿伟   |
|     5 | 阿伟   |
|  1000 | 阿伟   |
|  9999 | 阿伟   |
| 10000 | 阿伟   |
+-------+--------+
8 rows in set (0.00 sec)

mysql> show create table t18\G
*************************** 1. row ***************************
       Table: t18
Create Table: CREATE TABLE `t18` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10001 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)
```

索引：

- 在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。
- 索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。数据库使用索引以找到特定值，然后顺指针找到包含该值的行。这样可以使对应于表的SQL语句执行得更快，可快速访问数据库表中的特定信息。

## 七、唯一键

一张表中有往往有很多字段需要唯一性，数据不能重复，但是一张表中只能有一个主键：唯一键就可以解决表中有多个字段需要唯一性约束的问题。
唯一键的本质和主键差不多，唯一键允许为空，而且可以多个为空，空字段不做唯一性比较。关于唯一键和主键的区别：
我们可以简单理解成，主键更多的是标识唯一性的。而唯一键更多的是保证在业务上，不要和别的信息出现重复。

```sql
mysql> create table if not exists stus (
    -> stu_id bigint unsigned primary key auto_increment,
    -> name varchar(20) not null,
    -> qq varchar(20) not null comment '注意',
    -> telephone varchar(16) not null comment '注意'
    -> )auto_increment=100;
Query OK, 0 rows affected (0.08 sec)

mysql> desc stus;
+-----------+-----------------+------+-----+---------+----------------+
| Field     | Type            | Null | Key | Default | Extra          |
+-----------+-----------------+------+-----+---------+----------------+
| stu_id    | bigint unsigned | NO   | PRI | NULL    | auto_increment |
| name      | varchar(20)     | NO   |     | NULL    |                |
| qq        | varchar(20)     | NO   |     | NULL    |                |
| telephone | varchar(16)     | NO   |     | NULL    |                |
+-----------+-----------------+------+-----+---------+----------------+
4 rows in set (0.00 sec)
```

```sql
mysql> insert into stus (name, qq, telephone) values ('阿伟', '666@qq.com', '114514');
Query OK, 1 row affected (0.03 sec)

mysql> insert into stus (name, qq, telephone) values ('阿薇', '666@qq.com', '110110');
Query OK, 1 row affected (0.01 sec)
```

如果输错了，QQ可能出现重复，不符合唯一性。

现实世界中，有非常多的唯一性的值。一般而言，主键只在众多具有唯一性的属性列中选择成为主键而已，其他字段的唯一性，我们在建表的时候也要保证唯一性。但是因为主键只能有一个，所以提供了另一种保证数据列信息唯一性的方案——唯一键！

```sql
mysql> create table if not exists Stu (
    -> id bigint unsigned primary key auto_increment,
    -> name varchar(20) not null,
    -> qq varchar(32) unique comment 'qq虽然不是主键，但是他的唯一性需要保证',
    -> telephone varchar(16) unique comment '电话虽然不是唯一键，但也需要保证他的唯一性'
    -> )auto_increment=1000;
Query OK, 0 rows affected (0.12 sec)

mysql> desc Stu;
+-----------+-----------------+------+-----+---------+----------------+
| Field     | Type            | Null | Key | Default | Extra          |
+-----------+-----------------+------+-----+---------+----------------+
| id        | bigint unsigned | NO   | PRI | NULL    | auto_increment |
| name      | varchar(20)     | NO   |     | NULL    |                |
| qq        | varchar(32)     | YES  | UNI | NULL    |                |
| telephone | varchar(16)     | YES  | UNI | NULL    |                |
+-----------+-----------------+------+-----+---------+----------------+
4 rows in set (0.00 sec)

mysql> insert into Stu (name, qq, telephone) values ('阿伟', '666@qq.com', '7777');
Query OK, 1 row affected (0.01 sec)

mysql> insert into Stu (name, qq, telephone) values ('阿薇', '666@qq.com', '7777');
ERROR 1062 (23000): Duplicate entry '666@qq.com' for key 'Stu.qq'
```

```sql
mysql> insert into Stu (name, qq, telephone) values ('啊喂', '6666@qq.com', '77777');
Query OK, 1 row affected (0.01 sec)

mysql> select * from Stu;
+------+--------+-------------+-----------+
| id   | name   | qq          | telephone |
+------+--------+-------------+-----------+
| 1000 | 阿伟   | 666@qq.com  | 7777      |
| 1003 | 啊喂   | 6666@qq.com | 77777     |
+------+--------+-------------+-----------+
2 rows in set (0.00 sec)
```

主键是为了维护一条记录的唯一性，但是其他的，没有被选择成为主键的，他的唯一性依旧需要保证，这就有了唯一键。

## 八、外键

外键用于定义主表和从表之间的关系，维护主表和从表的约束：外键约束主要定义在从表上，主表则必须是有主键约束或`unique`约束。当定义外键后，要求外键列数据必须在主表的主键列存在或为`null`。

- 语法：

  ```sql
  foreign key (字段名) references 主表(列)
  ```

- 案例：

  ![image-20230421184445660](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230421184445660.png)

  先建立两套表结构：

  ```sql
  mysql> create table if not exists student_tb(
      -> id bigint primary key,
      -> name char(32) not null,
      -> class_id bigint
      -> );
  Query OK, 0 rows affected (0.14 sec)
  
  mysql> desc student_tb;
  +----------+----------+------+-----+---------+-------+
  | Field    | Type     | Null | Key | Default | Extra |
  +----------+----------+------+-----+---------+-------+
  | id       | bigint   | NO   | PRI | NULL    |       |
  | name     | char(32) | NO   |     | NULL    |       |
  | class_id | bigint   | YES  |     | NULL    |       |
  +----------+----------+------+-----+---------+-------+
  3 rows in set (0.00 sec)
  
  mysql> create table if not exists class_tb (
      -> id bigint primary key,
      -> name varchar(32) not null,
      -> teacher varchar(32) not null
      -> );
  Query OK, 0 rows affected (0.06 sec)
  
  mysql> desc class_tb;
  +---------+-------------+------+-----+---------+-------+
  | Field   | Type        | Null | Key | Default | Extra |
  +---------+-------------+------+-----+---------+-------+
  | id      | bigint      | NO   | PRI | NULL    |       |
  | name    | varchar(32) | NO   |     | NULL    |       |
  | teacher | varchar(32) | NO   |     | NULL    |       |
  +---------+-------------+------+-----+---------+-------+
  3 rows in set (0.00 sec)
  ```

  再插入一些值：

  ```sql
  mysql> insert into class_tb values (2101, "毛概", "徐凤阳");
  Query OK, 1 row affected (0.03 sec)
  
  mysql> insert into student_tb values (202103151422, '阿伟', 2101);
  Query OK, 1 row affected (0.01 sec)
  
  mysql> insert into student_tb values (202103156666, '猫圣君', 2101);
  Query OK, 1 row affected (0.01 sec)
  
  mysql> insert into student_tb values (202103150666, '王子', 2101);
  Query OK, 1 row affected (0.02 sec)
  
  mysql> insert into class_tb values (2102, "习思想", "徐凤阳");
  Query OK, 1 row affected (0.01 sec)
  
  mysql> insert into student_tb values (202103152016, '毛哥', 2102);
  Query OK, 1 row affected (0.02 sec)
  
  mysql> insert into student_tb values (202103152017, '毛圣钓', 2102);
  Query OK, 1 row affected (0.01 sec)
  
  mysql> insert into student_tb values (202103152018, '猫昇珺', 2102);
  Query OK, 1 row affected (0.01 sec)
  
  mysql> select * from student_tb;
  +--------------+-----------+----------+
  | id           | name      | class_id |
  +--------------+-----------+----------+
  | 202103150666 | 王子      |     2101 |
  | 202103151422 | 阿伟      |     2101 |
  | 202103152016 | 毛哥      |     2102 |
  | 202103152017 | 毛圣钓    |     2102 |
  | 202103152018 | 猫昇珺    |     2102 |
  | 202103156666 | 猫圣君    |     2101 |
  +--------------+-----------+----------+
  6 rows in set (0.00 sec)
  
  mysql> select * from class_tb;
  +------+-----------+-----------+
  | id   | name      | teacher   |
  +------+-----------+-----------+
  | 2101 | 毛概      | 徐凤阳    |
  | 2102 | 习思想    | 徐凤阳    |
  +------+-----------+-----------+
  2 rows in set (0.00 sec)
  ```

  某一天，阿伟转专业去了网工：

  ```sql
  mysql> update student_tb set class_id = 2102 where id = 202103151422;
  Query OK, 1 row affected (0.01 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  
  mysql> select * from student_tb;
  +--------------+-----------+----------+
  | id           | name      | class_id |
  +--------------+-----------+----------+
  | 202103150666 | 王子      |     2101 |
  | 202103151422 | 阿伟      |     2102 |
  | 202103152016 | 毛哥      |     2102 |
  | 202103152017 | 毛圣钓    |     2102 |
  | 202103152018 | 猫昇珺    |     2102 |
  | 202103156666 | 猫圣君    |     2101 |
  +--------------+-----------+----------+
  6 rows in set (0.00 sec)
  ```

  现在，在语义上，只有外键的关系，但是，默认依旧是两张独立的表！即表和表之间没有约束。——有关系，但没有约束。

  我们插入一条记录（202103152019, '猫昇裙', 2103)，发现表中有这条记录，但是没有2103这个班级！

  ```
  mysql> insert into student_tb values (202103152019, '猫昇裙', 2103);
  Query OK, 1 row affected (0.02 sec)
  
  mysql> select * from student_tb;
  +--------------+-----------+----------+
  | id           | name      | class_id |
  +--------------+-----------+----------+
  | 202103150666 | 王子      |     2101 |
  | 202103151422 | 阿伟      |     2102 |
  | 202103152016 | 毛哥      |     2102 |
  | 202103152017 | 毛圣钓    |     2102 |
  | 202103152018 | 猫昇珺    |     2102 |
  | 202103152019 | 猫昇裙    |     2103 |
  | 202103156666 | 猫圣君    |     2101 |
  +--------------+-----------+----------+
  7 rows in set (0.00 sec)
  ```

  删除2102这个班级，但是学生表中还有2102这个班级的学生。

  ```sql
  mysql> delete from class_tb where id=2102;
  Query OK, 1 row affected (0.01 sec)
  
  mysql> select * from class_tb;
  +------+--------+-----------+
  | id   | name   | teacher   |
  +------+--------+-----------+
  | 2101 | 毛概   | 徐凤阳    |
  +------+--------+-----------+
  1 row in set (0.00 sec)
  
  mysql> select * from student_tb;
  +--------------+-----------+----------+
  | id           | name      | class_id |
  +--------------+-----------+----------+
  | 202103150666 | 王子      |     2101 |
  | 202103151422 | 阿伟      |     2102 |
  | 202103152016 | 毛哥      |     2102 |
  | 202103152017 | 毛圣钓    |     2102 |
  | 202103152018 | 猫昇珺    |     2102 |
  | 202103152019 | 猫昇裙    |     2103 |
  | 202103156666 | 猫圣君    |     2101 |
  +--------------+-----------+----------+
  7 rows in set (0.00 sec)
  ```

  在有关系，有约束的情况下——外键约束

  重新建有外键约束的表：

  ```sql
  mysql> create table if not exists class_tb(
      -> id bigint primary key,
      -> name varchar(32) not null,
      -> teacher varchar(32) not null
      -> );
  Query OK, 0 rows affected (0.07 sec)
  
  mysql> desc class_tb;
  +---------+-------------+------+-----+---------+-------+
  | Field   | Type        | Null | Key | Default | Extra |
  +---------+-------------+------+-----+---------+-------+
  | id      | bigint      | NO   | PRI | NULL    |       |
  | name    | varchar(32) | NO   |     | NULL    |       |
  | teacher | varchar(32) | NO   |     | NULL    |       |
  +---------+-------------+------+-----+---------+-------+
  3 rows in set (0.01 sec)
  
  mysql> create table if not exists stu_tb(
      -> id bigint auto_increment,
      -> name varchar(32) not null,
      -> class_id bigint not null,
      -> primary key(id),
      -> foreign key(class_id) references class_tb(id)
      -> );
  Query OK, 0 rows affected (0.11 sec)
  
  mysql> desc stu_tb;
  +----------+-------------+------+-----+---------+----------------+
  | Field    | Type        | Null | Key | Default | Extra          |
  +----------+-------------+------+-----+---------+----------------+
  | id       | bigint      | NO   | PRI | NULL    | auto_increment |
  | name     | varchar(32) | NO   |     | NULL    |                |
  | class_id | bigint      | NO   | MUL | NULL    |                |
  +----------+-------------+------+-----+---------+----------------+
  3 rows in set (0.00 sec)
  ```

  插入些记录：

  ```sql
  mysql> insert into class_tb values (2101, '毛概', '老徐');
  Query OK, 1 row affected (0.02 sec)
  
  mysql> insert into class_tb values (2102, '习思想', '老徐');
  Query OK, 1 row affected (0.01 sec)
  
  mysql> insert into stu_tb (name, class_id) values ('阿伟', 2101);
  Query OK, 1 row affected (0.02 sec)
  
  mysql> insert into stu_tb (name, class_id) values ('王子', 2101);
  Query OK, 1 row affected (0.01 sec)
  
  mysql> insert into stu_tb (name, class_id) values ('毛哥', 2102);
  Query OK, 1 row affected (0.03 sec)
  ```

  在学生表中插入一个不存在的班级时会报错：

  ```sql
  mysql> insert into stu_tb (name, class_id) values ('毛', 2103);
  ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`ahweiDB`.`stu_tb`, CONSTRAINT `stu_tb_ibfk_1` FOREIGN KEY (`class_id`) REFERENCES `class_tb` (`id`))
  ```

  当班级中还有学生时，想要删掉班级也会报错：

  ```sql
  mysql> delete from class_tb where id = 2101;
  ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`ahweiDB`.`stu_tb`, CONSTRAINT `stu_tb_ibfk_1` FOREIGN KEY (`class_id`) REFERENCES `class_tb` (`id`))
  ```

  必须先删除学生表里的学生，然后才能删除班级：

  ```sql
  mysql> delete from stu_tb where class_id = 2101;
  Query OK, 2 rows affected (0.01 sec)
  
  mysql> delete from class_tb where id = 2101;
  Query OK, 1 row affected (0.01 sec)
  ```

  外键不仅仅是产生表和表之间的关联的，还有一个重要的属性往往被人忽略，外键在`Mysql`中还具有特定的约束规则，保证表和表的数据完整性和一致性。