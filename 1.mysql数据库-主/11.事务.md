# 11.事务

## 〇、准备

![image-20230530122714390](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230530122714390.png)

`mysqld`要提供事务机制，注定了`mysqld`内部编码和数据结构的支持。`mysqld`一定会同时存在多个事务，`mysqld`要对多个事物进行管理工作：先描述，再组织。

所以不要抽象地理解事务，事务最终一定要以某种数据结构+算法管理起来！

![image-20230530125702261](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230530125702261.png)

**CURD不加控制，会有什么问题？**

![image-20230530125734351](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230530125734351.png)

CURD满足什么属性，能解决上述问题？

1. 买票的过程得是原子的吧
2. 买票互相应该不能影响吧
3. 买完票应该要永久有效吧
4. 买前，和买后都要是确定的状态吧

## 一、什么是事务

事务就是一组`DML`语句组成，这些语句在逻辑上存在相关性，这一组`DML`语句要么全部成功，要么全部失败，是一个整体。`MySQL`提供一种机制，保证我们达到这样的效果。事务还规定不同的客户端看到的数据是不相同的。
事务就是要做的或所做的事情，主要用于处理操作量大，复杂度高的数据。假设一种场景：你毕业了，学校的教务系统后台 `MySQL`中，不在需要你的数据，要删除你的所有信息(一般不会:) ), 那么要删除你的基本信息(姓名，电话，籍贯等)的同时，也删除和你有关的其他信息，比如：你的各科成绩，你在校表现，甚至你在论坛发过的文章等。这样，就需要多条`MySQL`语句构成，那么所有这些操作合起来，就构成了一个事务。
正如我们上面所说，一个`MySQL`数据库，可不止你一个事务在运行，同一时刻，甚至有大量的请求被包装成事务，在向`MySQL`服务器发起事务处理请求。而每条事务至少一条`SQL`，最多很多`SQL`,这样如果大家都访问同样的表数据，在不加保护的情况，就绝对会出现问题。甚至，因为事务由多条`SQL`构成，那么，也会存在执行到一半出错或者不想再执行的情况，那么已经执行的怎么办呢？
所以，一个完整的事务，绝对不是简单的`sql`集合，还需要满足如下四个属性：

- 原子性：一个事务（`transaction`）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（`Rollback`）到事务开始前的状态，就像这个事务从来没有执行过一样。

- 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

- 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（`Read uncommitted`）、读提交（`read committed`）、可重复读（`repeatable read `）和串行化（`Serializable`）

- 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
  上面四个属性，可以简称为 `ACID`。

  > 原子性（`Atomicity`，或称不可分割性）
  > 一致性（`Consistency`）
  > 隔离性（`Isolation`，又称独立性）
  > 持久性（`Durability`）。

## 二、为什么会出现事务

事务被`MySQL`编写者设计出来,本质是为了当应用程序访问数据库的时候,事务能够简化我们的编程模型,不需要我们去考虑各种各样的潜在错误和并发问题.可以想一下当我们使用事务时,要么提交,要么回滚,我们不会去考虑网络异常了,服务器宕机了,同时更改一个数据怎么办对吧?因此事务本质上是为了应用层服务的.而不是伴随着数据库系统天生就有的.
备注：我们后面把`MySQL`中的一行信息，称为一行记录

## 三、事务的版本支持

在`MySQL`中只有使用了`Innodb`数据库引擎的数据库或表才支持事务，`MyISAM`不支持。
查看数据库引擎：

```mysql
mysql> show engines \G
*************************** 1. row ***************************
      Engine: ndbcluster
     Support: NO
     Comment: Clustered, fault-tolerant tables
Transactions: NULL
          XA: NULL
  Savepoints: NULL
*************************** 2. row ***************************
      Engine: FEDERATED
     Support: NO
     Comment: Federated MySQL storage engine
Transactions: NULL
          XA: NULL
  Savepoints: NULL
*************************** 3. row ***************************
      Engine: MEMORY
     Support: YES
     Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 5. row ***************************
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 7. row ***************************
      Engine: ndbinfo
     Support: NO
     Comment: MySQL Cluster system information storage engine
Transactions: NULL
          XA: NULL
  Savepoints: NULL
*************************** 8. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 9. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 10. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 11. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
11 rows in set (0.05 sec)
```

## 四、事务的提交方式

事务的提交方式常见的有两种：

- 自动提交
- 手动提交

查看事务提交方式

```mysql
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.12 sec)
```

用`SET`来改变`MySQL`的自动提交模式:

- `SET AUTOCOMMIT=0`禁止自动提交

  ```mysql
  mysql> SET AUTOCOMMIT=0;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> show variables like 'autocommit';
  +---------------+-------+
  | Variable_name | Value |
  +---------------+-------+
  | autocommit    | OFF   |
  +---------------+-------+
  1 row in set (0.01 sec)
  ```

- `SET AUTOCOMMIT=1`开启自动提交

  ```mysql
  mysql> SET AUTOCOMMIT=1; 
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> show variables like 'autocommit';
  +---------------+-------+
  | Variable_name | Value |
  +---------------+-------+
  | autocommit    | ON    |
  +---------------+-------+
  1 row in set (0.00 sec)
  ```

## 五、事务常见操作方式

简单银行用户表

- 提前准备

  把隔离级别设置成读未提交

  ```mysql
  mysql> set global transaction isolation level READ UNCOMMITTED;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select @@transaction_isolation;
  +-------------------------+
  | @@transaction_isolation |
  +-------------------------+
  | REPEATABLE-READ         |
  +-------------------------+
  1 row in set (0.00 sec)
  ```

- 创建测试表

  ```mysql
  mysql> create table if not exists emp(
      -> id int primary key,
      -> name varchar(32) not null,
      -> sal decimal(10, 2) not null default 0.0
      -> )engine=InnoDB;
  Query OK, 0 rows affected (0.04 sec)
  
  mysql> desc emp;
  +-------+---------------+------+-----+---------+-------+
  | Field | Type          | Null | Key | Default | Extra |
  +-------+---------------+------+-----+---------+-------+
  | id    | int           | NO   | PRI | NULL    |       |
  | name  | varchar(32)   | NO   |     | NULL    |       |
  | sal   | decimal(10,2) | NO   |     | 0.00    |       |
  +-------+---------------+------+-----+---------+-------+
  3 rows in set (0.01 sec)
  ```

- 正常演示 - 证明事务的开始与回滚

  ```mysql
  mysql> show variables like 'autocommit'; -- 查看事务是否自动提交。我们故意设置成自动提交，看看该选项是否影响begin
  +---------------+-------+
  | Variable_name | Value |
  +---------------+-------+
  | autocommit    | ON    |
  +---------------+-------+
  1 row in set (0.00 sec)
  
  mysql> start transaction; -- 开始一个事务begin也可以，推荐begin
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> savepoint save1; -- 创建一个保存点save1
  Query OK, 0 rows affected (0.00 sec)
  ```

  ![image-20230602084251439](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230602084251439.png)

  ```mysql
  mysql> insert into emp values (1, '阿伟', 500000); -- 插入一条记录
  Query OK, 1 row affected (0.00 sec)
  ```

  ![image-20230602084347428](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230602084347428.png)

  ```mysql
  mysql> savepoint save2; -- 创建一个保存点save2
  Query OK, 0 rows affected (0.00 sec)
  ```

  ```mysql
  mysql> rollback; -- 默认回滚到最开始，即便设置了很多savepoint
  Query OK, 0 rows affected (0.02 sec)
  ```

  ![image-20230602085318345](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230602085318345.png)

  ```mysql
  mysql> commit;
  Query OK, 0 rows affected (0.00 sec)
  ```

  `rollback to`可以回滚到任意位置

  ```sql
  mysql> begin;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> savepoint s1;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> insert into emp values (1, '阿伟', 500000);
  Query OK, 1 row affected (0.00 sec)
  
  mysql> savepoint s2;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> insert into emp values (2, '毛哥', 5000000);
  Query OK, 1 row affected (0.00 sec)
  ```

  ![image-20230602090409431](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230602090409431.png)

  ```mysql
  mysql> rollback to s2;
  Query OK, 0 rows affected (0.00 sec)
  ```

  ![image-20230602090526127](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230602090526127.png)

  ```mysql
  mysql> rollback to s1;
  Query OK, 0 rows affected (0.00 sec)
  ```

  ![image-20230602090620305](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230602090620305.png)

  ```mysql
  mysql> commit;
  Query OK, 0 rows affected (0.00 sec)
  ```

- 非正常演示1 - 证明未`commit`，客户端崩溃，`MySQL`自动会回滚（隔离级别设置为读未提交）

  ```mysql
  mysql> begin;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> insert into emp values (1, '阿伟', 500000);
  Query OK, 1 row affected (0.00 sec)
  
  mysql> insert into emp values (2, '毛哥', 5000000);
  Query OK, 1 row affected (0.00 sec)
  ```

  ![image-20230602091153153](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230602091153153.png)

  `ctrl \`使客户端崩溃：

  ![image-20230602091300418](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230602091300418.png)

  `mysql`自动回滚：

  ![image-20230602091323350](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230602091323350.png)

  所以从这里也可以看出，即使设置了自动提交，客户端崩溃的时候，也会自动回滚到最开始。
  
- 非正常演示2 - 证明`commit`了，客户端崩溃，`MySQL`数据不会在受影响，已经持久化

  ```mysql
  mysql> begin;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> insert into emp values (1, 'ahwei', 100);
  Query OK, 1 row affected (0.00 sec)
  
  mysql> insert into emp values (2, 'brother_mao', 1000000);
  Query OK, 1 row affected (0.00 sec)
  
  mysql> commit;
  Query OK, 0 rows affected (0.01 sec)
  
  mysql> Aborted
  [bbjsxl@VM-20-8-centos ~]$ 
  ```

  ![image-20230602112057650](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230602112057650.png)

  数据存在了，所以`commit`的作用是将数据持久化到`MySQL`中
  
 - 非正常演示3 - 对比试验。证明begin操作会自动更改提交方式，不会受MySQL是否自动提交影响

   ```mysql
   -- 终端 A
   mysql> select * from account;							-- 查看历史数据
   +----+--------+------------+
   | id | name   | blance     |
   +----+--------+------------+
   |  1 | 毛哥   | 1000000.00 |
   +----+--------+------------+
   1 row in set (0.00 sec)
   
   mysql> show variables like 'autocommit';				 -- 查看事务提交方式
   +---------------+-------+
   | Variable_name | Value |
   +---------------+-------+
   | autocommit    | ON    |
   +---------------+-------+
   1 row in set (0.00 sec)
   
   mysql> set autocommit=0;				   				-- 关闭自动提交
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> show variables like 'autocommit';				 -- 查看关闭之后结果
   +---------------+-------+
   | Variable_name | Value |
   +---------------+-------+
   | autocommit    | OFF   |
   +---------------+-------+
   1 row in set (0.00 sec)
   
   mysql> begin;							  			   -- 开启事务
   Query OK, 0 rows affected (0.00 sec)
   
   mysql> insert into account values (2, '阿伟', 500000);	 -- 插入记录
   Query OK, 1 row affected (0.00 sec)
   
   mysql> Aborted										   -- 异常终止
   
   -- 终端B
   mysql> select * from account; 							-- 终端A崩溃前
   +----+--------+------------+
   | id | name   | blance     |
   +----+--------+------------+
   |  1 | 毛哥   | 1000000.00 |
   |  2 | 阿伟   |  500000.00 |
   +----+--------+------------+
   2 rows in set (0.00 sec)
   
   mysql> select * from account;							-- 终端A崩溃后，自动回滚
   +----+--------+------------+
   | id | name   | blance     |
   +----+--------+------------+
   |  1 | 毛哥   | 1000000.00 |
   +----+--------+------------+
   1 row in set (0.00 sec)
   ```

     `autocommit`是否自动提交，并不影响用户手动开启事务（`begin...commit`）

 - 非正常演示4 - 证明单条`SQL`与事务的关系

   ```sql
   ...
   ```

   历史上我们有很多CURD操作，单sql和今天的事务有什么关系？

   单sql默认都是会以事务的方式进行提交，只不过事务只有一个sql语句。

   我们没有用`begin`开启事务，我们就默认执行我们的`sql`，就是一个事务，`sql`执行完毕会按照`autocommit`来决定是否自动提交。

结论：

> 只要输入`begin`或者`start transaction`，事务便必须要通过`commit`提交，才会持久化，与是否设置`set autocommit`无关。
> 事务可以手动回滚，同时，当操作异常，`MySQL`会自动回滚
> 对于`InnoDB`每一条`SQL`语言都默认封装成事务，自动提交。（`select`有特殊情况，因为`MySQL`有`MVCC`）
> 从上面的例子，我们能看到事务本身的原子性(回滚)，持久性(`commit`)
> 那么隔离性？一致性？

事务操作注意事项:

> 如果没有设置保存点，也可以回滚，只能回滚到事务的开始。直接使用`rollback`(前提是事务还没有提交)
> 如果一个事务被提交了（`commit`），则不可以回退（`rollback`）
> 可以选择回退到哪个保存点
> `InnoDB`支持事务，`MyISAM`不支持事务
> 开始事务可以使`start transaction`或者`begin`

## 六、事务隔离级别

### 如何理解隔离性1

- `MySQL`服务可能会同时被多个客户端进程(线程)访问，访问的方式以事务方式进行
- 一个事务可能由多条`SQL`构成，也就意味着，任何一个事务，都有执行前，执行中，执行后的阶段。而所谓的原子性，其实就是让用户层，要么看到执行前，要么看到执行后。执行中出现问题，可以随时回滚。所以单个事务，对用户表现出来的特性，就是原子性。
- 但，毕竟所有事务都要有个执行过程，那么在多个事务各自执行多个`SQL`的时候，就还是有可能会出现互相影响的情况。比如：多个事务同时访问同一张表，甚至同一行数据。
- 就如同你妈妈给你说：你要么别学，要学就学到最好。至于你怎么学，中间有什么困难，你妈妈不关心。那么你的学习，对你妈妈来讲，就是原子的。那么你学习过程中，很容易受别人干扰，此时，就需要将你的学习隔离开，保证你的学习环境是健康的。
- 数据库中，为了保证事务执行过程中尽量不受干扰，就有了一个重要特征：隔离性
- 数据库中，允许事务受不同程度的干扰，就有了一种重要特征：隔离级别（在隔离事务这件事情上，做的不同程度的妥协，即在效率和平衡性上找平衡，前提依旧保证数据安全）

### 隔离级别
- 读未提交【`Read Uncommitted`】： 在该隔离级别，所有的事务都可以看到其他事务没有提交的执行结果。（实际生产中不可能使用这种隔离级别的），但是相当于没有任何隔离性，也会有很多并发问题，如脏读，幻读，不可重复读等，我们上面为了做实验方便，用的就是这个隔离性。

  ```sql
  -- 几乎没有加锁，虽然效率高，但是问题太多，严重不建议采用
  -- 终端A
  -- 设置隔离级别为 读未提交
  mysql> set global transaction isolation level read uncommitted;
  Query OK, 0 rows affected (0.00 sec)
  -- 重启客户端
  mysql> select @@transaction_isolation;
  +--------------------------+
  | @@transaction_isolation  |
  +--------------------------+
  | 	  READ-UNCOMMITTED     |
  +--------------------------+
  1 row in set, 1 warning (0.00 sec)
  mysql> select * from account;
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 1000000.00  |
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  mysql> begin; -- 开启事务
  Query OK, 0 rows affected (0.00 sec)
  mysql> update account set blance=1230000.0 where id=1; -- 更新指定行
  Query OK, 1 row affected (0.05 sec)
  Rows matched: 1 Changed: 1 Warnings: 0
  -- 没有commit哦！！！
  -- 终端B
  mysql> begin;
  mysql> select * from account;
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 1230000.00  | -- 读到终端A更新但是未commit的数据[insert，delete同样]
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  -- 一个事务在执行中，读到另一个执行中事务的更新(或其他操作)但是未commit的数据，这种现象叫做脏读
  (dirty read)
  ```

  事务是作为一个整体，但在读未提交的情况下，一个事务还没有提交，另一个事务就读到了他的数据，这种现象就叫做脏读！

- 读提交【`Read Committed`】 ：该隔离级别是大多数数据库的默认的隔离级别（不是`MySQL`默认的）。它满足了隔离的简单定义:一个事务只能看到其他的已经提交的事务所做的改变。这种隔离级别会引起不可重复读，即一个事务执行时，如果多次 select， 可能得到不同的结果。

  ```sql
  -- 终端A
  mysql> set global transaction isolation level read committed;
  Query OK, 0 rows affected (0.00 sec)
  -- 重启客户端
  mysql> select * from account; -- 查看当前数据
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 1230000.00  |
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  mysql> begin; -- 手动开启事务，同步的开始终端B事务
  Query OK, 0 rows affected (0.00 sec)
  mysql> update account set blance=3210000.0 where id=1; -- 更新毛哥数据
  Query OK, 1 row affected (0.00 sec)
  Rows matched: 1 Changed: 1 Warnings: 0
  -- 切换终端到终端B，查看数据。
  mysql> commit; -- commit提交！
  Query OK, 0 rows affected (0.01 sec)
  -- 切换终端到终端B，再次查看数据。
  -- 终端B
  mysql> begin; -- 手动开启事务，和终端A一前一后
  Query OK, 0 rows affected (0.00 sec)
  mysql> select * from account; -- 终端A commit之前，查看不到
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 1230000.00  | -- 老的值
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  -- 终端A commit之后，看到了！
  -- but，此时还在当前事务中，并未commit，那么就造成了，同一个事务内，同样的读取，在不同的时间段(依旧还在事务操作中！)，读取到了不同的值，这种现象叫做不可重复读(non reapeatable read)！！（这个是问题吗？？）
  mysql> select *from account;
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 3210000.00  | -- 新的值
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  ```

  事务B在运行过程中读到了不一样的数据，因为事务A提交了，这种现象叫做不可重复读。

- 可重复读【`Repeatable Read`】： 这是`MySQL`默认的隔离级别，它确保同一个事务，在执行中，多次读取操作数据时，会看到同样的数据行。但是会有幻读问题。

  ```sql
  -- 终端A
  mysql> set global transaction isolation level repeatable read; -- 设置全局隔离级别 RR
  Query OK, 0 rows affected (0.01 sec)
  -- 关闭终端重启
  mysql> select @@transaction_isolation;
  +-------------------------+
  | @@transaction_isolation |
  +-------------------------+
  | 	 REPEATABLE-READ	 | -- 隔离级别RR
  +-------------------------+
  1 row in set, 1 warning (0.00 sec)
  mysql> select *from account; -- 查看当前数据
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 3210000.00  |
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  mysql> begin; -- 开启事务，同步的，终端B也开始事务
  Query OK, 0 rows affected (0.00 sec)
  mysql> update account set blance=43210000.0 where id=1; -- 更新数据
  Query OK, 1 row affected (0.00 sec)
  Rows matched: 1 Changed: 1 Warnings: 0
  -- 切换到终端B，查看另一个事务是否能看到
  mysql> commit; -- 提交事务
  -- 切换终端到终端B，查看数据。
  -- 终端B
  mysql> begin;
  Query OK, 0 rows affected (0.00 sec)
  mysql> select * from account; -- 终端A中事务 commit之前，查看当前表中数据，数据未更新
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 3210000.00  |
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  mysql> select * from account; -- 终端A中事务 commit 之后，查看当前表中数据，数据未更新
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 张三 | 3210000.00  |
  | 2 | 李四 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  -- 可以看到，在终端B中，事务无论什么时候进行查找，看到的结果都是一致的，这叫做可重复读！
  mysql> commit; -- 结束事务
  Query OK, 0 rows affected (0.00 sec)
  mysql> select * from account; -- 再次查看，看到最新的更新数据
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 43210000.00 |
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  -- ------------------------------------------------------------------------------------------------------------
  -- 如果将上面的终端A中的update操作，改成insert操作，会有什么问题？？
  -- 终端A
  mysql> select *from account;
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 3210000.00  |
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  mysql> begin; -- 开启事务，终端B同步开启
  Query OK, 0 rows affected (0.00 sec)
  mysql> insert into account (id,name,blance) values(3, '毛弟', 54320000.0);
  Query OK, 1 row affected (0.00 sec)
  -- 切换到终端B，查看另一个事务是否能看到
  mysql> commit; -- 提交事务
  Query OK, 0 rows affected (0.00 sec)
  -- 切换终端到终端B，查看数据。
  mysql> select * from account;
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 43210000.00 |
  | 2 | 阿伟 | 100000.00   |
  | 3 | 毛弟 | 54320000.00 |
  +----+--------+----------+
  3 rows in set (0.00 sec)
  -- 终端B
  mysql> begin; -- 开启事务
  Query OK, 0 rows affected (0.00 sec)
  mysql> select * from account; -- 终端A commit前 查看
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 43210000.00 |
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  mysql> select * from account; -- 终端A commit后 查看
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 43210000.00 |
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  mysql> select * from account; -- 多次查看，发现终端A在对应事务中insert的数据，在终端B的事务周期中，也没有什么影响，也符合可重复的特点。但是，一般的数据库在可重复读情况的时候，无法屏蔽其他事务insert的数据(为什么？因为隔离性实现是对数据加锁完成的，而insert待插入的数据因为并不存在，那么一般加锁无法屏蔽这类问题),会造成虽然大部分内容是可重复读的，但是insert的数据在可重复读情况被读取出来，导致多次查找时，会多查找出来新的记录，就如同产生了幻觉。这种现象，叫做幻读(phantom read)。很明显，MySQL在RR级别的时候，是解决了幻读问题的(解决的方式是用Next-Key锁(GAP+行锁)解决的。)。
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 43210000.00 |
  | 2 | 阿伟 | 100000.00   |
  +----+--------+----------+
  2 rows in set (0.00 sec)
  mysql> commit; -- 结束事务
  Query OK, 0 rows affected (0.00 sec)
  mysql> select * from account; -- 看到更新
  +----+--------+----------+
  | id | name   | blance   |
  +----+--------+----------+
  | 1 | 毛哥 | 43210000.00 |
  | 2 | 阿伟 | 100000.00   |
  | 3 | 毛弟 | 54320000.00 |
  +----+--------+----------+
  3 rows in set (0.00 sec)
  ```

  可重复读本质其实就是在一个事务内部，不受任何事务操作的影响，每次查到的数据都是一致的。

  幻读在`mysql`中不存在，在其他数据库中可能存在（无法解决`insert`的不可重复读的问题）。

- 串行化【`Serializable`】: 这是事务的最高隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决了幻读的问题。它在每个读的数据行上面加上共享锁，。但是可能会导致超时和锁竞争（这种隔离级别太极端，实际生产基本不使用）

  ```sql
  --对所有操作全部加锁，进行串行化，不会有问题，但是只要串行化，效率很低，几乎完全不会被采用
  --终端A
  mysql> set global transaction isolation level serializable;
  Query OK, 0 rows affected (0.00 sec)
  mysql> select @@transaction_isolation;
  +-------------------------+
  | @@transaction_isolation |
  +-------------------------+
  |	 SERIALIZABLE		 |
  +-------------------------+
  1 row in set, 1 warning (0.00 sec)
  mysql> begin; -- 开启事务，终端B同步开启
  Query OK, 0 rows affected (0.00 sec)
  mysql> select * from account; -- 两个读取不会串行化，共享锁
  +----+--------+----------+
  | id | name | blance |
  +----+--------+----------+
  | 1 | 毛哥 | 43210000.00 |
  | 2 | 阿伟 | 100000.00 |
  | 3 | 毛弟 | 54320000.00 |
  +----+--------+----------+
  3 rows in set (0.00 sec)
  mysql> update account set blance=1.00 where id=1; -- 终端A中有更新或者其他操作，会阻塞。直到终端B事务提交。
  Query OK, 1 row affected (18.19 sec)
  Rows matched: 1 Changed: 1 Warnings: 0
  -- 终端B
  mysql> begin;
  Query OK, 0 rows affected (0.00 sec)
  mysql> select * from account; -- 两个读取不会串行化
  +----+--------+----------+
  | id | name | blance |
  +----+--------+----------+
  | 1 | 毛哥 | 43210000.00 |
  | 2 | 阿伟 | 100000.00 |
  | 3 | 毛弟 | 54320000.00 |
  +----+--------+----------+
  3 rows in set (0.00 sec)
  mysql> commit; -- 提交之后，终端A中的update才会提交。
  Query OK, 0 rows affected (0.00 sec)
  ```

  ![image-20230604203755788](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230604203755788.png)

隔离级别如何实现：隔离，基本都是通过锁实现的，不同的隔离级别，锁的使用是不同的。常见有，表锁，行锁，读锁，写锁，间隙锁(`GAP`),`Next-Key`锁(`GAP`+行锁)等。不过，我们目前现有这个认识就行，先关注上层使用。

事务中，所谓的提交`commit`，是不是把数据进行刷盘呢？

——不是，刷盘的过程是`mysql`自己会执行的。`commit`设置事务的状态，表示该数据已经算是交付给了`mysqld`。

总结：

- 其中隔离级别越严格，安全性越高，但数据库的并发性能也就越低，往往需要在两者之间找一个平衡点。

- 不可重复读的重点是修改和删除：同样的条件, 你读取过的数据,再次读取出来发现值不一样了

  幻读的重点在于新增：同样的条件, 第1次和第2次读出来的记录数不一样

- 说明：`mysql`默认的隔离级别是可重复读,一般情况下不要修改

- 上面的例子可以看出，事务也有长短事务这样的概念。事务间互相影响，指的是事务在并行执行的时候，即都没有`commit`的时候，影响会比较大

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| :------: | :--: | :--------: | :--: | :----: |
| 读未提交 | yes  |    yes     | yes  | 不加锁 |
| 读已提交 |  no  |    yes     | yes  | 不加锁 |
| 可重复读 |  no  |     no     |  no  | 不加锁 |
| 可串行化 |  no  |     no     |  no  |  加锁  |

​																																												         yes：会发生该问题

​																																														no：不会发生该问题

### 查看与设置隔离性

- 查看

  ```sql
  -- 查看全局隔级别
  mysql> SELECT @@global.transaction_isolation;
  +--------------------------------+
  | @@global.transaction_isolation |
  +--------------------------------+
  | READ-UNCOMMITTED               |
  +--------------------------------+
  1 row in set (0.00 sec)
  ```

  ```sql
  -- 查看会话(当前)全局隔级别：本次登录（一次登录是一个会话）对应的隔离级别
  mysql> SELECT @@session.transaction_isolation;
  +---------------------------------+
  | @@session.transaction_isolation |
  +---------------------------------+
  | READ-UNCOMMITTED                |
  +---------------------------------+
  1 row in set (0.00 sec)
  ```

  ```mysql
  -- 默认同上
  mysql> SELECT @@transaction_isolation;
  +-------------------------+
  | @@transaction_isolation |
  +-------------------------+
  | READ-UNCOMMITTED        |
  +-------------------------+
  1 row in set (0.00 sec)
  ```

  ```sql
  -- 设置
  -- 设置当前会话 or 全局隔离级别语法
  SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}
  
  -- 注意，如果没有现象，关闭mysql客户端，重新连接。
  ```

### 如何理解隔离性2

**数据库并发的场景有三种**：

- 读-读 ：不存在任何问题，也不需要并发控制
- 读-写 ：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
- 写-写 ：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失(后面补充)

#### 读-写

多版本并发控制（`MVCC`）是一种用来解决**读-写**冲突 的**无锁并发控制**
为事务分配单向增长的事务ID，为每个修改保存一个版本，版本与事务ID关联，读操作只读该事务开始前的数据库的快照。 所以`MVCC` 可以为数据库解决以下问题

- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
- 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

理解 MVCC 需要知道三个前提知识：

- 3个记录隐藏字段
- `undo`日志
- `Read View`

**3个记录隐藏列字段**
`DB_TRX_ID`：6 byte，最近修改( 修改/插入 )事务`ID`，记录创建这条记录/最后一次修改该记录的事务`ID`
`DB_ROLL_PTR`: 7 byte，回滚指针，指向这条记录的上一个版本（简单理解成，指向历史版本就行，这些数据一般在`undo log`中）
`DB_ROW_ID`: 6 byte，隐含的自增`ID`（隐藏主键），如果数据表没有主键，`InnoDB`会自动以`DB_ROW_ID`产生一个聚簇索引
补充：实际还有一个删除`flag`隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除`flag`变了

假设测试表结构是：

```sql
mysql> create table if not exists student(
name varchar(11) not null,
age int not null
);
mysql> insert into student (name, age) values ('张三', 28);
Query OK, 1 row affected (0.05 sec)
mysql> select * from student;
+--------+-----+
| name   | age |
+--------+-----+
| 张三   | 28  |
+--------+-----+
1 row in set (0.00 sec)
```

上面描述的意思是：

| `name` | `age` | `DB_TRX_ID`(创建该记录的事务`ID`) | `DB_ROW_ID`(隐式主键) | `DB_ROLL_PTR`(回滚指针) |
| :----: | :---: | :-------------------------------: | :-------------------: | :---------------------: |
|  张三  |  28   |              `null`               |           1           |         `null`          |

我们目前并不知道创建该记录的事务`ID`，隐式主键，我们就默认设置成`null`，1。第一条记录也没有其他版本，我们设置回滚指针为`null`。

![image-20230604234159605](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230604234159605.png)

**`undo`日志**
这里不想细讲，但是有一件事情得说清楚，`MySQL`将来是以服务进程的方式，在内存中运行。我们之前所讲的所有机制：索引，事务，隔离性，日志等，都是在内存中完成的，即在`MySQL`内部的相关缓冲区中，保存相关数据，完成各种判断操作。然后在合适的时候，将相关数据刷新到磁盘当中的。

所以，我们这里理解undo log，简单理解成，就是`MySQL`中的一段内存缓冲区，用来保存日志数据的就行。

**模拟`MVCC`**
现在有一个事务10(仅仅为了好区分)，对 student 表中记录进行修改( update )：将 name (张三)改成 name (李四)。

- 事务10,因为要修改，所以要先给该记录加行锁。
- 修改前，现将改行记录拷贝到`undo log`中，所以，`undo log`中就有了一行副本数据。(原理就是写时拷贝)
- 所以现在`MySQL`中有两行同样的记录。现在修改原始记录中的`name`，改成 '李四'。并且修改原始记录的隐藏字段`DB_TRX_ID`为当前 事务10的`ID`, 我们默认从`10`开始，之后递增。而原始记录的回滚指针`DB_ROLL_PTR`列，里面写入`undo log`中副本数据的地址，从而指向副本记录，既表示我的上一个版本就是它。
- 事务10提交，释放锁。

![image-20230604235646256](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230604235646256.png)

![image-20230605001500901](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230605001500901.png)

这样，我们就有了一个基于链表记录的历史版本链。所谓的回滚，无非就是用历史数据，覆盖当前数据。
上面的一个一个版本，我们可以称之为一个一个的快照。

单纯从回滚角度看：

真实的做法：`undo log`里保存相反的`sql`

**一些思考**
上面是以更新（`upadte`）主讲的,如果是`delete`呢？一样的，别忘了，删数据不是清空，而是设置flag为删除即可。也可以形成版本。如果是`insert`呢？因为`insert`是插入，也就是之前没有数据，那么`insert`也就没有历史版本。但是一般为了回滚操作，insert的数据也是要被放入undo log中，如果当前事务commit了，那么这个undo log 的历史insert记录就可以被清空了。

总结一下，也就是我们可以理解成，`update`和`delete`可以形成版本链，`insert`暂时不考虑。
那么`select`呢？
首先，`select`不会对数据做任何修改，所以，为`select`维护多版本，没有意义。不过，此时有个问题，就是：select读取，是读取最新的版本呢？还是读取历史版本？

- 当前读：读取最新的记录，就是当前读。增删改，都叫做当前读，`select`也有可能当前读，比如：`select lock in share mode`(共享锁), `select for update`（这个好理解，我们后面不讨论）
- 快照读：读取历史版本(一般而言)，就叫做快照读。(这个我们后面重点讨论)

我们可以看到，在多个事务同时删改查的时候，都是当前读，是要加锁的。那同时有`select`过来，如果也要读取最新版(当前读)，那么也就需要加锁，这就是串行化。
但如果是快照读，读取历史版本的话，是不受加锁限制的。也就是可以并行执行！换言之，提高了效率，即`MVCC`的意义所在。那么，是什么决定了，`select`是当前读，还是快照读呢？隔离级别!

那为什么要有隔离级别呢？
事务都是原子的。所以，无论如何，事务总有先有后。但是经过上面的操作我们发现，事务从`begin->CURD->commit`，是有一个阶段的。也就是事务有执行前，执行中，执行后的阶段。但，不管怎么启动多个事务，总是有先有后的。那么多个事务在执行中，`CURD`操作是会交织在一起的。那么，为了保证事务的“有先有后”，是不是应该让不同的事务看到它该看到的内容，这就是所谓的隔离性与隔离级别要解决的问题。

先来的事务，应不应该看到后来的事务所做的修改呢?——不应该

那么，如何保证，不同的事务，看到不同的内容呢？也就是如何如何实现隔离级别？

**Read View**

`Read View`就是事务进行**快照读**操作的时候生产的读视图 (`Read View`)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个`ID`, 这个`ID`是递增的，所以最新的事务，`ID`值越大)
`Read View`在`MySQL`源码中,就是一个类，本质是用来进行可见性判断的。 即当我们某个事务执行快照读的时候，对该记录创建一个`Read View`读视图，把它比作条件,用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的`undo log`里面的某个版本的数据。
下面是`ReadView`结构,但为了减少负担，我们简化一下:

```c++
class ReadView {
// 省略...
private:
/** 高水位，大于等于这个ID的事务均不可见*/
trx_id_t m_low_limit_id
/** 低水位：小于这个ID的事务均可见 */
trx_id_t m_up_limit_id;
/** 创建该 Read View 的事务ID*/
trx_id_t m_creator_trx_id;
/** 创建视图时的活跃事务id列表*/
ids_t m_ids;
/** 配合purge，标识该视图不需要小于m_low_limit_no的UNDO LOG，
* 如果其他视图也不需要，则可以删除小于m_low_limit_no的UNDO LOG*/
trx_id_t m_low_limit_no;
/** 标记视图是否被关闭*/
bool m_closed;
// 省略...
};
m_ids; //一张列表，用来维护Read View生成时刻，系统正活跃的事务ID
up_limit_id; //记录m_ids列表中事务ID最小的ID(没有写错)
low_limit_id; //ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1(也没有写错)
creator_trx_id //创建该ReadView的事务ID
```

当我们`begin`启动事务的时候，是没有`read view`的，但肯定有事务`ID`和事务对象，当我们首次进行`select`的时候，`mysqld`会自动给我们形成`read view`视图。

我们在实际读取数据版本链的时候，是能读取到每一个版本对应的事务`ID`的，即：当前记录的`DB_TRX_ID`。
那么，我们现在手里面有的东西就有，当前快照读的`ReadView`和 版本链中的某一个记录的`DB_TRX_ID`。
所以现在的问题就是，当前快照读，应不应该读到当前版本记录。一张图，解决所有问题！

![image-20230605005758920](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230605005758920.png)

对应源码策略：

![image-20230605005858658](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230605005858658.png)

如果查到不应该看到当前版本，接下来就是遍历下一个版本，直到符合条件，即可以看到。上面的`readview`是当你进行`select`的时候，会自动形成。

整体流程

假设当前有条记录：

| `name` | `age` | `DB_TRX_ID`(创建该记录的事务`ID`) | `DB_ROW_ID`(隐式主键) | `DB_ROLL_PTR`(回滚指针) |
| :----: | :---: | :-------------------------------: | :-------------------: | :---------------------: |
|  张三  |  28   |              `null`               |           1           |         `null`          |

事务操作：

| 事务1 [id=1] | 事务2 [id=2] | 事务3 [id=3] | 事务4 [id=4] |
| :----------: | :----------: | :----------: | :----------: |
|   事务开始   |   事务开始   |   事务开始   |   事务开始   |
|     ...      |     ...      |     ...      | 修改且已提交 |
|    进行中    |    快照读    |    进行中    |              |
|     ...      |     ...      |     ...      |              |

- 事务4：修改`name`(张三) 变成`name`(李四)

- 当事务2对某行数据执行了快照读 ，数据库为该行数据生成一个`Read View`读视图

  ```c++
  //事务2的 Read View
  m_ids; // 1,3
  up_limit_id; // 1
  low_limit_id; // 4 + 1 = 5，原因：ReadView生成时刻，系统尚未分配的下一个事务ID
  creator_trx_id // 2
  ```

此时版本链是：

![image-20230605185319211](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230605185319211.png)

- 只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务。

  ![image-20230605185438926](C:\Users\20848\AppData\Roaming\Typora\typora-user-images\image-20230605185438926.png)

- 我们的事务2在快照读该行记录的时候，就会拿该行记录的`DB_TRX_ID`去跟`up_limit_id`,`low_limit_id`和活跃事务`ID`列表(`trx_list`) 进行比较，判断当前事务2能看到该记录的版本。

  ```c++
  //事务2的 Read View
  m_ids; // 1,3
  up_limit_id; // 1
  low_limit_id; // 4 + 1 = 5，原因：ReadView生成时刻，系统尚未分配的下一个事务ID
  creator_trx_id // 2
  //事务4提交的记录对应的事务ID
  DB_TRX_ID=4
  //比较步骤
  DB_TRX_ID（4）< up_limit_id（1） ? 不小于，下一步
  DB_TRX_ID（4）>= low_limit_id(5) ? 不大于，下一步
  m_ids.contains(DB_TRX_ID) ? 不包含，说明，事务4不在当前的活跃事务中。
  //结论
  故，事务4的更改，应该看到。
  所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本
  ```

## 七、一致性(Consistency)

- 事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库只包含事务成功提交的结果时，数据库处于一致性状态。如果系统运行发生中断，某个事务尚未完成而被迫中断，而改未完成的事务对数据库所做的修改已被写入数据库，此时数据库就处于一种不正确（不一致）的状态。因此一致性是通过原子性来保证的。
- 其实一致性和用户的业务逻辑强相关，一般`MySQL`提供技术支持，但是一致性还是要用户业务逻辑做支撑，也就是，一致性，是由用户决定的。
- 而技术上，通过AID保证C